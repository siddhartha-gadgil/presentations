<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">

	<title>ATP in Maths</title>

	<meta name="description" content="ICTS 2024 summer school lecture">
	<meta name="author" content="Siddhartha Gadgil">

	<meta name="apple-mobile-web-app-capable" content="yes" />
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

	<meta name="viewport"
		content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/black.css" id="theme">

	<!-- Code syntax highlighting -->
	<link rel="stylesheet" href="lib/css/zenburn.css">
	<link rel="stylesheet" href="kwk.css">

	<link rel="icon" href="IIScLogo.jpg">

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
		document.getElementsByTagName('head')[0].appendChild(link);
	</script>

	<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
</head>

<body>

	<div class="reveal">

		<!-- Any section element inside this container is displayed as a slide -->
		<section class="slides">
			<section data-transition="slide">
				<h3> Automated Theorem Proving</h3>
				<h4>and its</h4>
				<h3>role in Mathematics</h3>
				<h4>Siddhartha Gadgil</h4>
				<p>Department of Mathematics</p>
				<p>Indian Institute of Science, Bangalore</p>


			</section>

			<section>
				<ul>
					<li> Generative AI has become a popular sensation. </li>
					<li class="fragment"> In particular Large Language Models can generate code, database queries etc.
					</li>
					<li class="fragment">Much less well known are the major advances in computer proofs (<em>Formal
							proof systems</em>), both within
						mathematics and in industry.</li>
					<li class="fragment"> Computer proofs complement very well generative AI. </li>
					<li class="fragment"> Thus, there is great potential in the interaction between <strong>Mathematical
							Reasoning</strong>, <strong>Formal Proof systems</strong> and <strong>Artificial
							Intelligence.</strong>
					</li>

				</ul>
			</section>


			<section data-transition="zoom-in slide-out" data-background-image="campus.jpg">
				<h1>Mathematical Proofs</h1>
			</section>

			<section data-background-color="teal">
				<h4> A proof: Sum of Angles in a Triangle</h4>
				<ul>
					<li class="fragment"> Consider a triangle $ABC$.</li>
					<li class="fragment"> Draw a line through $A$ parallel to $BC$.
						<center><img src="angle_sum.png" height="250" /></center>
					</li>
					<li class="fragment"> Use equality of interior opposite angles.</li>
					<li class="fragment"> Use angles on a line add up to 180 degrees.</li>

				</ul>
			</section>
			<section data-background-color="teal">
				<h4>Another proof: infinitely many primes</h4>
				<ul>
					<li class="fragment"> For any $n$, we show that there exists a prime $p$ such that $p > n$.</li>
					<li class="fragment"> Consider the number $n!+1$, where $n! = 1 \times 2 \times \dots \times n$.
					</li>
					<li class="fragment"> Let $p$ be the smallest prime factor of $n!+1$.
					</li>
					<li class="fragment"> If $p \leq n$ then $p | n!$ so $p \nmid n!+1$.</li>
					<li class="fragment"> Hence $p$ is a prime greater than $n$.</li>

				</ul>
			</section>

			<section data-background-color="teal">
				<h4 id="what-went-into-proofs">Components of Proving (Reasoning)</h4>
				<ul>
					<li class="fragment"><strong>Intuition:</strong> Analogies, Associations etc.
						<ul>
							<li class="fragment">
								Auxiliary Constructions.
							</li>
							<li class="fragment">
								<p>Theorems/Definitions to use.</p>
							</li>
							<li class="fragment">
								Intermediate Lemmas and statements.
							</li>
						</ul>
					</li>
					<li class="fragment">
						<p><strong>Logical/Algorithmic:</strong> Deductions, Computations.</p>
					</li>
					<li class="fragment">
						Intuition is based on <strong>tacit knowledge</strong>, acquired by learning. <span
							class="fragment"> (High Kolmogorov complexity?)</span>
					</li>
					<li class="fragment">For mathematics <em>in the large</em>, we also need
						<strong>modularity/abstraction</strong>.
					</li>
				</ul>

			</section>

			<section data-background-color="teal">
				<h4 id="what-went-into-proofs">Modularity/Abstraction</h4>
				<ul>
					<li class="fragment"><strong>Modularity:</strong> being decomposable into parts:
						<ul>
							<li class="fragment">
								Often in a hierarchical way.
							</li>
							<li class="fragment">
								So that the <em>interface (surface)</em> through which the component interacts is
								relatively simple.
							</li>
							<li class="fragment">
								Details of the component are <em>abstracted</em>.
							</li>
						</ul>
					</li>
					<li class="fragment">
						Knowledge is also modular, allowing focus on a specific part and level of abstraction.
					</li>
					<li class="fragment">
						In Mathematics, we use <strong>definitions</strong> and <strong>theorems</strong> for
						abstraction: <em>fully unfolded proofs</em> are incomprehensible.
					</li>
				</ul>

			</section>

			<section data-background-color="teal">
				<h4 id="what-went-into-proofs">Properties of Computer Proof systems</h4>
				<ul>
					<li>Trust/verification level.</li>
					<li>Generality.</li>
					<li>Autonomy/level of Automation.</li>
					<li>Nature of reasoning: purely algorithmic versus using intuition from learning.</li>
					<li>Whether modularity can be represented and used.</li>
				</ul>
				<p class="fragment">We shall consider various proof systems differing in most of these properties, except we do not consider unverified algorithms.</p>

			</section>

			<section data-transition="zoom-in concave-out" data-background-image="campus.jpg">

				<h2 style="color:#fffdd0">Interactive Theorem Provers</h2>
			</section>



			<section data-transition="concave" data-background-color="#002b36">
				<ul>
					<li><em>Interactive Theorem Provers</em> are software systems where proofs are
						obtained by human-machine
						collaboration.</li>
					<li class="fragment">The computer both finds (parts of) proofs and verifies
						<strong>correctness</strong>.
					</li>
					<li class="fragment">With interactive theorem provers, mathematics on a large scale can be digitied
						(<em>formalized</em>) in a modular fashion, facilitating by automation.
					</li>
					<li class="fragment">Indeed the <em>Lean Mathematical Library</em> has most undergraduate
						mathematics in it, and some advanced topics.
					</li>
					<li class="fragment">We see an <a href="https://live.lean-lang.org/#codez=JYWwDg9gTgLgBAWQIYwBYBtgCMBQEwCmAdnAHIo44D0AtDXAKICuAxpgCYDkAznGgdAIg4EEvzgAqCcCIAzGcBhN2BEbLhgooAtykA6HAAkCUVQHNgAN2JwZfVKtnQQALjhOocAtagBPOAAGRAEANPYmqgQAHsDcMLxIGlogqkRMIFgmgWBwgKZEcMF6cDRUOPyCwtGx8QD6MvJEigQ1mtq8ABQkboCohACUcG6AwEQaYSSAJkQacIDkRGQoegAKyao5LgC8cFi+OHBw6ATwK+sgMgBiSCxwnXAAhHAA1HAAjL3bcKhI1u6PAwU3909wQAGRAC1hstjsdkgwGB0P5yDA9ERmhBZDUzPBXpDobC4NxWCwaugYDU8SwLpi4FCYf5ZOcYNBgEh0C0INxXu9PtCfvCFktJqDNhSqTjjkQzgTWikKdxQDkANpImootEwMKkglEkn4sK0lj0rRMlncAC67I+qRWvwmhzBQux/j2StRRAgxLMBApMhgUAgbwpHNUqEAgQQ/HKAYiJfrcBeCIVjqXB2JZ2DVdfrGeg4BS4yLTucjZnYztonS/bGA29AEEEobgEe+oPaPMTyaQ7GTwFkqK0ZlQ8GDvT0ACZLqLxTUm3Aai9Y8W9RowIjXWOk0qkZXXkxuMscEA" target="_blank"> example</a> on the lean server.

					</li>
				</ul>
			</section>

			<!-- <section data-background-iframe="https://live.lean-lang.org/#codez=JYWwDg9gTgLgBAWQIYwBYBtgCMBQEwCmAdnAHIo44D0AtDXAKICuAxpgCYDkAznGgdAIg4EEvzgAqCcCIAzGcBhN2BEbLhgooAtykA6HAAkCUVQHNgAN2JwZfVKtnQQALjhOocAtagBPOAAGRAEANPYmqgQAHsDcMLxIGlogqkRMIFgmgWBwgKZEcMF6cDRUOPyCwtGx8QD6MvJEigQ1mtq8ABQkboCohACUcG6AwEQaYSSAJkQacIDkRGQoegAKyao5LgC8cFi+OHBw6ATwK+sgMgBiSCxwnXAAhHAA1HAAjL3bcKhI1u6PAwU3909wQAGRAC1rMYHoiM0ILIamZ4AAeAA+cG4rBYNXQMBqqJYFyR7nOMGgwCQ6BaEF4NVe70+YBWYIWS0moM2rx2SDp6H8xyIZ3RrRSbJRoByAG1ITVobCYGEcejMdi0WFZITiaTydwALrUj6penjZnrVk7dmc/x7SUwogQLFmAhCmQwKAQN5CmmqVCAQIIfjlAMREv1uLK2JpNHLAXLg7Es7BqKpYRK0pLgQtN4e5p3OGuTIZ20UJrpD7regCCCH1wf3fUHtcjgqMxpDsGPAWQwrRmVDwL29PQAJkuPL5NTrcBqLxDefjGjAEJtQ+jkshJdeTG4yxwQA" data-background-interactive></iframe>
			</section> -->


			<section data-transition="concave" data-background-color="#002b36">
				<ul>
					<li>As more mathematics is in such libraries, it becomes easier and more enjoyable to formalize even
						more.</li>
					<li class="fragment">Automation is also improving, which also facilitates formalization.
					</li>
					<li class="fragment"><strong>Lean 4</strong> is a <em>programming language</em> seamlessly
						integrated with an <em>interactive
							theorem prover</em>, which helps with formalization and makes it useful in new ways.
					</li>
					<li class="fragment">Lean can help ensure a super-human
						level of correctness.
					</li>
					<li class="fragment"> One hopes this is <strong>without super-human effort</strong>.
					</li>
				</ul>
			</section>

			<section data-transition="concave" data-background-color="#002b36">
				<h4>Who guards the guards?</h4>
				<ul>
					<li class="fragment">
						A computer verified proof is only as trustworthy as the system that verified the proof.
					</li>
					<li class="fragment">
						Following the <em>de Bruijn</em> principle, proofs are <em>verified</em> by a small
						<em>trusted
							kernel</em>, which can be thoroughly checked.
					</li>
					<li class="fragment">
						For example, the Lean theorem prover has independent (small) proof checkers, one written in
						a different language (Rust).
					</li>
					<li class="fragment">
						In a specific case, one only has to check that the <strong>definitions</strong> and the
						<strong>statement</strong> are correct, which is typically not hard especially if they use a
						library.
					</li>
				</ul>

			</section>

			<section data-transition="concave" data-background-color="#002b36">
				<h4>The Liquid Tensor experiment</h4>
				<ul>
					<li class="fragment">In December 2020, Peter Scholze challenged the formalization community to
						computer verify a foundational theorem of <em>Condensed
							Mathematics</em>.</li>
					<blockquote class="fragment">
						— with this theorem, the hope that the condensed formalism can be fruitfully applied to real
						functional analysis stands or falls. I think the theorem is of utmost foundational importance,
						so being 99.9% sure is not enough.
					</blockquote>

				</ul>
			</section>
			<section data-background-color="#002b36">
				<ul>
					<li>This was taken up by the Lean community led by Johann Commelin, with active
						collaboration from Scholze.</li>

					<li class="fragment">
						In about six months a major step, <strong>Theorem 9.4</strong> of Scholze's notes, was proved.
					</li>
					<li class="fragment">
						Scholze said this was the part where he was worried about, and that he was now satisfied
						that
						the correctness of his result was checked.
					</li>
					<li class="fragment">
						About an year later, the origin goal, <strong>Theorem 9.1</strong> was proved in Lean.
					</li>
					<li class="fragment">Scholze said he understood aspects of his proof after the formalization which
						he hadn't earlier.</li>
				</ul>
			</section>

			<section data-background-color="#002b36">
				<h4>Polynomial Freiman–Ruzsa conjecture</h4>
				<ul>
					<li class="fragment">In April 2024, Gowers-Green-Manners-Tao proved a long-standing conjecture
						called the <em>Polynomial Freiman–Ruzsa conjecture</em>.</li>
					<li class="fragment">Terry Tao started a project to formalize this in Lean.</li>
					<li class="fragment">This was a relatively self-contained piece of mathematics.</li>
					<li class="fragment">The formalization was complete in about 3 weeks, with about 20 contributors.
					</li>
				</ul>
			</section>

			<section data-transition="convex" data-background-color="#002b36">
				<ul>
					<li>
						A proof in Lean is not only correct, but also:
						<ul>
							<li>Modular with precise abstraction boundaries that are fully respected.</li>
							<li>
								Each piece is correct exactly as stated.
							</li>
						</ul>
					</li>
					<li class="fragment">This facilitates focusing on different parts and different levels of details of
						the proof.</li>
					<li class="fragment">Collaboration is facilitated:
						<ul>
							<li class="fragment">Trust is not required to accept contributions.</li>
							<li class="fragment">Contributions are possible from those who only understand some
								ingredients.</li>
							<li class="fragment"> (Components of) Proofs suggested by Large Language Models such as
								GPT-4 can be used.</li>

						</ul>
					</li>
				</ul>
			</section>

			<section data-background-color="#002b36">
				<h4>Equational Magmas: Terry Tao's experiment</h4>
				<ul>
					<li class="fragment">A <em>Magma</em> is a set $G$ with a single operation $\circ: G \times G \to G$.</li>
					<li class="fragment">We consider Magma's with a single equational axiom, such as $x \circ y = y \circ x$.</li>
					<li class="fragment">For all pairs of equational axioms using the circle operation up to $4$ times, we ask whether the first axiom implies the second.</li>
					<li class="fragment">This was about 20 million questions.
					</li>
				</ul>
			</section>

			<section data-background-color="#002b36">
				<ul>
					<li class="fragment">These were studied in a collaboration using Lean's Zulip channel, and a Github workflow.
					</li>
					<li class="fragment">To prove an implication involves a deduction.
					</li>
					<li class="fragment">To disprove an implication we construct a <em>model</em> for the first axiom which does not satisfy the second.
					</li>
					<li class="fragment">Progress came from <em>deduction engines</em>, human ideas, and a remarkable interplay of these.
					</li>
					<li class="fragment">"The dog that didn't bark" &mdash; deep learning did not have a significant role.
					</li>
					<li class="fragment">Contrary to what many people excepted, <strong>every</strong> implication was either proved or disproved.
					</li>



				</ul>
			</section>



			
			<section data-transition="zoom-in concave-out" data-background-image="campus.jpg">
				<h2 style="color:#fffdd0">Automated Theorem Provers</h2>
			</section>

			<section data-transition="convex" data-background-color="teal">
				<h4>SAT (and SMT) Solvers</h4>
				<ul>
					<li class="fragment">
						The <strong>SAT</strong> (<em>boolean satisfiability</em>) problem asks whether we can solve
						finitely many logical equations involving boolean variables.
					<li class="fragment">By the Cook-Levine
						theorem, any finite problem in NP (easily verifiable) can be reduced to SAT.
					</li>
					<li class="fragment">SAT solvers, programs solving SAT, have been used to solve maths problems, for
						example:
					</li>
					<li class="fragment"><strong>Boolean Pythagorean triples problem:</strong> Can we colour
						each
						positive integers either red or blue, so that no Pythagorean triple of integers $a$, $b$, $c$,
						satisfying $a^{2}+b^{2}=c^{2}$ is monochromatic?</li>
				</ul>
			</section>

			<section data-transition="convex" data-background-color="teal">
				<h4>Resolution Theorem Provers</h4>
				<ul>
					<li class="fragment"><strong>Resolution Theorem Provers</strong> with <strong>Unification</strong>
						can solve problems in <em>first order logic</em>.
					</li>
					<li class="fragment">
						In principle, first-order logic includes all of mathematics; <span class="fragment">but, in
							practice,
							the proof must depend on a small number of axioms.</span>
					</li>
					<li class="fragment"> <strong>Robbins conjecture</strong> was a characterization of Boolean algebras
						in
						terms of
						associativity and commutativity of $\vee$ and the Robbins equation
						$\neg(\neg(a\vee b)\vee \neg(a \vee \neg b)) = a$.</li>
					<li class="fragment"> This was conjectured in the 1930s, and proved in 1996 by the
						automated theorem prover EQP.</li>
				</ul>
			</section>


			<section data-transition="zoom-in convex-out" data-background-image="sea.jpg">
				<h1>&nbsp;</h1>
				<h2 style="color:#fffdd0">Hybrid Systems:</h2>
				<h2 style="color:#fffdd0">Deep Learning</h2>
				<h4 style="color:#fffdd0">with</h4>
				<h2 style="color:#fffdd0">Automated/Interactive Provers</h2>

				<p>&nbsp;</p>
			</section>



			<section data-transition="convex" data-background="#b5533c">
				<h4>AlphaGeometry</h4>
				<ul>

					<li class="fragment">AlphaGeometry (from Google-Deepmind) is an AI system that can solve geometry
						problems.
					</li>
					<li class="fragment">More precisely, it can attempt to solve geometry problems which can be
						represented in a certain symbolic way,
						which includes most IMO geometry problems.
					</li>
					<li class="fragment">The score of AlphaGeometry on these problems was between the average score of
						the <strong>Silver medallists</strong> and the average score of the <strong>Gold
							medallists</strong> on those problems.</li>
				</ul>
			</section>

			<section data-transition="convex" data-background="#b5533c">
				<h4>Components of AlphaGeometry</h4>
				<ul>

					<li class="fragment"><strong>Deductive Database + Algebraic Reasoning (DD+AR):</strong> a powerful
						and efficient deductive system for reasoning about geometry problems (extending earlier work).
					</li>
					<li class="fragment">A <strong>Language Model</strong> that suggests <em>auxiliary
							constructions.</em>
					</li>
					<li class="fragment">Generation of <strong>synthetic data</strong> to train the language model.</li>
				</ul>
			</section>

			<section data-transition="convex" data-background="#b5533c">
				<h4>Deductive Database (+ Algebraic Reasoning)</h4>
				<ul>

					<li class="fragment">In a <strong>Deductive Database</strong>, we have (efficiently represented):
						<ul>
							<li>A finite collection of points.</li>
							<li>Relations between points, lines through them etc.; for example <code>perp A B C D</code>
							</li>
						</ul>
					</li>
					<li class="fragment">Rules of deduction let us deduce consequences.
					</li>
					<li class="fragment">For instance if <code>AB</code> and <code>CD</code>
						are both perpendicular to <code>BC</code> then they are parallel.</li>
					<li class="fragment">Iterating deduction with all applicable rules till expansion halts
						gives all consequences that <strong>do not require</strong> adding a point.</li>
				</ul>
			</section>

			<section data-transition="convex" data-background="#b5533c">
				<h4>(Deductive Database +) Algebraic Reasoning</h4>
				<ul>

					<li class="fragment">In addition to deducing relations from other relations, AlphaGeometry deduces
						from algebraic relations for angles, lengths and ratios.</li>
					<li class="fragment">All the relations obtained in the setup are of the form $a + b = c + d$.
					</li>
					<li class="fragment">Hence, they can be represented by a matrix and all consequences efficiently
						derived using <strong>Gaussian Elimination.</strong></li>
				</ul>
			</section>

			<section data-transition="convex" data-background="#b5533c">
				<h4>Synthetic data</h4>
				<ul>

					<li class="fragment">Millions of random configurations were generated, and all theorems were
						deduced.</li>
					</li>
					<li class="fragment">100 million theorems were found, for which minimal proofs were generated.</li>
					</li>
					<li class="fragment">Whenever the statement of a theorem did not involve a point but the proof did,
						the proof involved an <em>auxiliary construction</em> (10 million).</li>
					<li class="fragment">A language model ($\approx 150M$ params) was <em>pretrained</em> on all proofs
						and <em>fine-tuned</em> to predict auxiliary constructions.
					</li>
					<li class="fragment">No IMO problem was in the synthetic data.</li>
				</ul>
			</section>

			<section data-transition="convex" data-background="#b5533c">
				<h4>AlphaGeometry: Solving Problems</h4>
				<ul>

					<li class="fragment">Given a geometry problem represented symbolically, all deductions are made
						using DD+AR.</li>
					<li class="fragment">If the deductions do not include the final conclusion, then the language model
						is used to generate candidate auxiliary constructions.</li>
					</li>
					<li class="fragment">For (some of) the auxiliary constructions, all deductions are made after the
						construction.</li>
					<li class="fragment">This process is repeated in a <strong>beam search</strong>.</li>
				</ul>
			</section>

			<section data-transition="zoom-in convex-out" data-background-image="AlphaGeomPfs.jpg"
				data-background-size="contain">
			</section>


			<section>
				<section data-background-color="#002b36" data-transition="concave">
					<ul>
						<li>Large Language Models have remarkable abilities, roughly corresponding to our
							<em>intuition</em>.
							<ul>
								<li class="fragment">They can reason by analogy.</li>
								<li class="fragment">This includes mixing and matching concepts from different domains.
								</li>
								<li class="fragment">They are excellent at Natural Language.</li>
								<li class="fragment">They are familiar with a huge amount of stuff.</li>
								<li class="fragment">They can combine their broad knowledge with specific knowledge
									from their input.</li>
							</ul>
						</li>
						<li class="fragment">They are, however, <strong>terrible</strong> at at avoiding logical
							fallacies
							and judging
							correctness.</li>
					</ul>
				</section>






			<section data-transition="zoom" data-background="hills.png">
				<h1 style="color:#fffdd0">GPT-4 Examples</h1>
			</section>


			<section data-background-color="#002b36">
				<h4>Infinitely many primes ending in $7$</h4>
				<ul>

					<li class="fragment">
						To prove that there are infinitely many prime numbers ending with 7, we can use a method similar
						to Dirichlet's theorem on arithmetic progressions. Dirichlet's theorem states that for any two
						coprime integers \( a \) and \( b \), there are infinitely many primes in the arithmetic
						progression \( a + nb \) (where \( n \) is a non-negative integer).
					</li>
				</ul>
			</section>
			<section data-background-color="#002b36">
				<ul>
					<li>
						In this problem, we want to show that there are infinitely many primes ending in 7. This is
						equivalent to showing that there are infinitely many primes in the arithmetic progression \( 10k
						+ 7 \), where \( k \) is a non-negative integer. Here, \( a = 7 \) and \( b = 10 \).
					</li>
					<li>
						First, we need to check that 7 and 10 are coprime. Since \(\gcd(7, 10) = 1\), they are indeed
						coprime. According to Dirichlet's theorem, this implies that there are infinitely many primes of
						the form \( 10k + 7 \).
					</li>
					
				</ul>
			</section>
			<section data-background-color="#002b36">
				<small>
				<p>
					To illustrate the argument further, consider the following steps:</li>
				</p>
					<ol>
						<li> <strong>Definition and Application of Dirichlet's Theorem:</strong>
							Dirichlet's theorem asserts that if \( a \) and \( b \) are coprime, the arithmetic sequence
							\( a, a+b, a+2b, \ldots \) contains infinitely many primes. Here, \( a = 7 \) and \( b = 10
							\) are coprime, thus the sequence \( 7, 17, 27, \ldots \) contains infinitely many primes.
						</li>
						<li> <strong>Sequence \( 10k + 7 \):</strong>
							The sequence \( 10k + 7 \) where \( k \) is a non-negative integer, generates numbers that
							all end in 7 (e.g., \( 7, 17, 27, 37, 47, \ldots \)).
						</li>
						<li> <strong>Primes in the Sequence:</strong>
							By Dirichlet's theorem, since 7 and 10 are coprime, there are infinitely many primes in this
							sequence \( 10k + 7 \).</li>
					</ol>
					<ul><li>
						Therefore, the sequence \( 10k + 7 \) contains infinitely many prime numbers, and these primes
						all end in the digit 7. Hence, there are infinitely many primes ending in 7. This completes the
						proof.
					</li></ul>
				</small>

				</ul>
			</section>

			<section>
				<a href="https://gemini.google.com/app/2f44749b24289e5c" target="_blank">Gemini examples</a>
			</section>


			<section data-background-color="#002b36">
				<h4>Proofs by GPT-4</h4>
				<ul>
					<li class="fragment">GPT-4 correcly answered many non-trivial questions, including ones we used to select Ph.D. students.</li>
					<li class="fragment">However, it failed to answer some easier questions, giving <strong>wrong proofs</strong>.</li>
					<li class="fragment">It repeatedly used false statements in proofs, such as <em>every increasing sequence is unbounded</em>, <span class="fragment">even though when asked whether the statement was true it gave a counterexample.</span></li>
					<li class="fragment">The hope is that pairing with Lean will give errors, and LLMs can correct with this feedback.</li>
			</section>

			<section>
			<section data-background-color="#002b36">
				<h4>Auxiliary tasks</h4>
				<ul>
				<li>Many auxiliary tasks facilitating generating and translating proofs iteratively can be performed by Language models.
				<ul>
					<li class="fragment">Describing Lean statements, proofs and code in natural language.</li>
					<li class="fragment">Identifying mathematical terms used, their synonyms, and rephrasing using these.</li>
					<li class="fragment">Rewriting proofs in a structured format.</li>
					<li class="fragment">Examining proofs and pointing out missing details.</li>
				</ul>
				</li>
			</section>

			<section data-background-color="#002b36">
				<ul>
					<li>Mathematical terms and synonyms: “Suppose $E\subset \mathbb{R}^k$ is uncountable, and let $P$ be
						the
						set of condensation points of $E$. Then $P$ is perfect.”</li>
				</ul>
				<pre><code data-trim data-noescape class="language-json">
						[{"term": "subset",
							"synonyms": [ "subgroup", "part", "included in", "component" ]},
							{"term": "uncountable",
							"synonyms": [ "non-countable", "uncountably infinite", "non-denumerable", "unlisted" ]},
							{"term": "set",
							"synonyms": [ "collection", "aggregate", "ensemble", "grouping" ]},
							{"term": "condensation points",
							"synonyms": [ "limit points", "accumulation points", "cluster points",
							"point of accumulation" ]},
							{"term": "perfect",
							"synonyms": [ "complete", "whole", "intact", "unblemished" ]}]
						  </code></pre>
				</li>
			</section>
			<section data-background-color="#002b36">
				<ul>
					<li>Describe the following Lean code.</li>
				</ul>
				<pre><code data-trim data-noescape>
						variable {α : Type}[LinearOrder α]

						def smallest (l: List α)(_: l ̸= []): α :=
						match l with
						| h::t =>
						if c:(t = []) then
						h else min h (smallest t c)

						theorem smallest_mem (l : List α) (hyp : l ̸= []) :
						smallest l hyp ∈ l := by
						sorry

						theorem smallest_le (l : List α) (hyp : l ̸= []) :
						∀ a : α, a ∈ l → smallest l hyp ≤ a :=
						sorry
						  </code></pre>
				</li>
			</section>
			<section data-background-color="#002b36">
				<ul>
					<li>The Lean code defines a function and two theorems
						related to lists of elements of a type with a linear
						order.
					</li>
					<li>
						The function <code>smallest</code> takes a list <code>l</code> and a proof that
						<code>l</code> is not empty. It then returns the smallest element in
						the list. If the list contains only one element, that
						element is returned. Otherwise, the smallest element
						is the minimum of the first element and the smallest
						element of the tail of the list.
					</li>
			</section>

			<section data-background-color="#002b36">
				<ul>
					<li>The first theorem, <code>smallest_mem</code>, states that if a list <code>l</code>
						is not empty, then the smallest element of <code>l</code> is an
						element of <code>l</code>.
					</li>
					<li>
						The second theorem, <code>smallest_le</code>, states that if a list
						<code>l</code> is not empty, then for any element <code>l</code> of <code>l</code>, the
						smallest element of <code>l</code> is less than or equal to <code>l</code>. In
						other words, the smallest element is less than or equal
						to every element in the list.
					</li>
			</section>


			<section data-background-color="#002b36">
				<h4>A harder problem</h4>
				<ul>
					<li class="fragment"><strong>Problem:</strong> Find all $2 \times 2$ matrices with rational entries
						such that
						$A^5 = I$.</li>
					<span class="fragment">
						<li><strong>Proof:</strong>
							A $2 \times 2$ matrix $A$ over the rationals is of the form

							\[
							A = \begin{pmatrix}
							a & b \\
							c & d
							\end{pmatrix},
							\]

							where $a, b, c, d \in \mathbb{Q}$. </li>
						<li>
							We want to find all such $A$ such that $A^5 = I$, where $I$ is the $2 \times 2$ identity
							matrix.
						</li>
					</span>
			</section>

			<section data-background="#002b36">
				<ul>
					<li>We can start by noting that the minimal polynomial of such an $A$ must divide $x^5 - 1 = 0$.
						Over the rationals, this polynomial factors into irreducible factors as

						\[
						x^5 - 1 = (x - 1)(x^4 + x^3 + x^2 + x + 1).
						\]
					</li>
					<li>
						So the minimal polynomial of $A$ must either be $x - 1$ or $x^4 + x^3 + x^2 + x + 1 = 0$.
					</li>
					<li>
						However, the second polynomial has degree $4$ and the minimal polynomial of a $2 \times 2$
						matrix can have degree at most $2$, so $A$ must satisfy $x - 1 = 0$. That is, $A = I$.
					</li>
					<li>
						To verify our claim, we note that if $A = I$, then indeed $A^5 = I^5 = I$. So the only $2 \times
						2$ matrix over the rationals such that $A^5 = I$ is $A = I$.
					</li>
				</ul>
			</section>
			<section data-background-color="#002b36">
				<ul>
					<li>
						To verify our claim, we note that if $A = I$, then indeed $A^5 = I^5 = I$. So the only $2 \times
						2$ matrix over the rationals such that $A^5 = I$ is $A = I$.
					</li>
					<li>
						<strong>Problem:</strong> Prove that the polynomial $x^4 + x^3 + x^2 + x + 1$ is irreducible
						over the rationals.
					</li>
					<li>
						To prove that the polynomial $x^4 + x^3 + x^2 + x + 1$ is irreducible over the rationals, one
						approach is by using a substitution and then applying Eisenstein's Criterion, a well-known
						theorem in number theory that provides a sufficient condition for a polynomial ...
					</li>

				</ul>
			</section>

			<section data-background-color="#002b36">
				<h4>Analysis questions</h4>
				<ul>
					<li class="fragment"><strong>Problem:</strong> Suppose $f:\mathbb{R} \to \mathbb{R}$ is a smooth
						function such that $f''(x) > 0$ for all $x \in \mathbb{R}$. Prove that $f$ is unbounded.</li>
					<li class="fragment"><strong>Prove or disprove:</strong> Suppose $f:\mathbb{R} \to \mathbb{R}$ is a
						smooth function such that $f'(x) > 0$ for all $x \in \mathbb{R}$. Then $f$ is unbounded.
					</li>
					<li class="fragment">Persistently wrong answers, even with guidance like split into cases.</li>
					<li class="fragment">Proofs either used <em>every increasing sequence is unbounded</em> or assumed
						that the maximum is attained for the functions.</li>
			</section>

			<section data-background-color="#002b36">
				<ul>
					<h4>Analysis questions (continued)</h4>
					<li>When asked to prove or disprove <em>every increasing sequence is unbounded</em>, consistently
						gave a counterexample.</li>
					<li class="fragment">Another model, Mistral medium, was much better at such questions.</li>
					<li class="fragment">For the task of finding mathematical terms, Mistral 7B running locally on
						the mathematics workstation was fine.</li>
				</ul>
			</section>

			<section data-background-color="#002b36">
				<h4>Homogeneous lengths</h4>
				<ul>
					<li><strong>Problem:</strong> Consider <em>length functions</em> $l: F \to
						\mathbb{R}$ on the non-abelian free groups on 2 generators, i.e., functions satisfying the
						triangle inequality and positivity conditions.
						We say a length function $l$ is homogeneous if $l(g^n)= |n|l(g)$ for all elements $g$ in the
						free group.

						Prove that the word metric on the non-abelian free groups on 2 generators is not homogeneous.
					</li>
					<li>... Then, if we take $n = 2$, we have $l_W((ab)^2) = 4$, <strong>but $2l_W(ab)
							= 4$ not $|2|l_W(ab)= 2*2 = 4$</strong>. Therefore, ...</li>
				</ul>
			</section>

			<section data-background-color="#002b36">
				<h4>Seeking details</h4>
				<ul>
					<li class="fragment"><strong>Original statement:</strong> Let $G$ be a group with an abelian normal
						subgroup $K$ such that $Q=G/K$ is also abelian.
						As $K$ is abelian, the conjugation action of $G$ on $K$ induces a group action of $Q$ on $K$.
					</li>
					<li class="fragment">Firstly, it's important to understand what the conjugation action is. In any
						group $G$, we can define an action of $G$ on itself by conjugation: $g \cdot h = ghg^{-1}$ for
						all $g, h \in G$.</li>

				</ul>
			</section>
			<section data-background-color="#002b36">
				<ul>
					<li>Since $K$ is a normal subgroup of $G$, it is invariant under conjugation by elements of $G$.
						This means that if $k \in K$ and $g \in G$, then $gkg^{-1} \in K$. </li>

					<li>Hence, the conjugation action of $G$ on itself restricts to an action of $G$ on $K$.
					</li>
					<li>
						The question is then how this action induces an action of the quotient group $Q=G/K$ on $K$.
					</li>
					<li>By the definition of a quotient group, the elements of $Q$ are the cosets $gK$ for $g \in G$.
					</li>

				</ul>
			</section>
			<section data-background-color="#002b36">
				<ul>

					<li>We can define the action of $Q$ on $K$ as follows: for $gK \in Q$ and $k \in K$, let $gK \cdot k
						= gkg^{-1}$. </li>
					<li>To show that this is well-defined, suppose that $gK = hK$ for some $g, h \in G$. Then $h^{-1}g
						\in K$, so there exists $k' \in K$ such that $h^{-1}g = k'$.
						Then for any $k \in K$, we have

						$$hkh^{-1} = k'kk'^{-1}k^{-1}k' = k',$$

						because $K$ is abelian. So the action of $Q$ on $K$ is well-defined. Next, we need to check that
						this gives a group action. ...</li>
				</ul>

			</section>

			<section data-background-color="#002b36">
				<h4>Structured proof</h4>
				<small>
					<ul>
						<li> If $A$ is a square matrix with $A^3$ the identity, then $A$ is diagonalizable.</li>
					</ul>
					<pre class="fragment"><code data-trim data-noescape class="language-json">
						[{"assumption": "$A$ is a square matrix and $A^3 = I$"},
						{"observation": "$x^3 - 1$ has three distinct roots: $1, e^{2\pi i/3}, e^{4\pi i/3}$"},
						{"theorem": "Cayley-Hamilton theorem: Every square matrix satisfies its characteristic polynomial"},
						{"assertion": {
						"claim": "The minimal polynomial of $A$ divides $x^3 - 1$",
						"justification": "The minimal polynomial of a matrix $A$ divides any polynomial that 
						$A$ satisfies",
						"using": ["Cayley-Hamilton theorem"]
						}},
						{"observation": "The roots of $x^3 - 1$ are distinct"},
						{"assertion": {
						"claim": "The minimal polynomial of $A$ is a product of distinct linear factors",
						"justification": "The only way the minimal polynomial of $A$ can divide $x^3 - 1$ is if it is
							a product of distinct linear factors",
						"using": ["The minimal polynomial of $A$ divides $x^3 - 1", 
						"The roots of $x^3 - 1$ are distinct"]
						}},
						{"theorem": "A matrix is diagonalizable if and only if its minimal polynomial is a 
									product of distinct linear factors"},
						{"assertion": {
						"claim": "$A$ is diagonalizable",
						"justification": "By the previous theorem and the fact that the minimal polynomial of $A$ 
						is a product of distinct linear factors",
						"using": ["A matrix is diagonalizable if and only if its minimal polynomial is a product of 
						distinct linear factors", "The minimal polynomial of $A$ is a product of distinct linear factors"]
						}}]
						  </code></pre>
				</small>
			</section>
			</section>
			<section data-transition="zoom-in convex-out" data-background-image="lake.jpg">
				<h1 style="color:goldenrod">Mathematics in the Large</h1>
				<p>&nbsp;</p>
			</section>

			<section data-background-color="teal">
				<h3>Diophantine equations</h3>
				<ul>
					<li class="fragment">A <em>Diophantine equation</em> is an equation with integer coefficients, for which we seek integer (or rational) solutions. </li>
					<li class="fragment">There is no algorithm that can decide whether a Diophantine equation has a solution.</li>
					<li class="fragment">However, in specific cases theorems can prove or disprove the existence of solutions, even for refinements such as families of equations and numbers of solutions.</li>
					<li class="fragment">A famous example is the equation $x^n + y^n = z^n$.</li>
				</ul>

			</section>

			<section data-background-color="teal">
				<h3>Word problem</h3>
				<ul>
					<li class="fragment">We consider words in an alphabet, with words considered equivalent if they are related by a given collection of substitutions of subwords. </li>
					<li class="fragment">For example, the alphabet may be $\{\alpha, \beta\}$ with substitutions $\alpha\beta = \beta\alpha$.</li>
					<li class="fragment">In general, there is no algorithm that can solve the word problem.</li>
					<li class="fragment">In the above example, we can use <em>normal forms</em>.</li>
					<li class="fragment">In other cases, we can show that if words of length $n$ and $m$ are related, then they are related using at most some $C(n, m)$ moves.</li>
				</ul>

			</section>

			<section data-background-color="teal">
				<h3>"Progress in Mathematics''</h3>
				<ul>
					<li class="fragment">We start with basic questions, maybe from nature. </li>
					<li class="fragment">We develop techniques that can answer these in some cases; the general case is often unsolvable.</li>
					<li class="fragment">The questions and techniques are abstracted.</li>
					<li class="fragment">This leads to new questions, for the techniques to be applicable; and also <em>natural questions</em>.</li>
					<li class="fragment">Hopefully, progress at higher abstractions let us answer the original questions in more cases.</li>
					<li class="fragment">We hope that Artificial Intelligence and Formal Proof Systems are superpowers for all the steps.</li>
				</ul>

			</section>

			<section data-background-color="teal">
				<ul>
					<li>A fundamental scientific problem is to predict the $3$-dimensional structure of a protein from its sequence of Amino acids.</li>
					<li class="fragment">An AI system <strong>Alphafold 2</strong> extended the class of proteins for which we have structures from a few thousand to about 200  million.</li>
					<li class="fragment">For a specific protein, though, we cannot be sure Alphafold  is correct.</li>
					<li class="fragment">A developing mathematical theory will let us predict <strong>with proof</strong> the structure for larger and larger classes of proteins.</li>
				</ul>
			</section>


			<section>
				<h4>Summary</h4>
				<ul>
					<li class="fragment">
						Language models can be used for many core and auxiliary tasks in <strong>Mathematical
							Reasoning</strong>, due to their
						intuitive reasoning, natural language skills, knowledge and ability to learn from examples.
					</li>
					<li class="fragment">Due to their unreliability, it is natural to combine them with Interactive
						Theorem Provers.</li>
					<li class="fragment">Combining of AI, ITPs and symbolic algebra etc should
						enable <em>tools</em> for mathematics.
					<li class="fragment">We can extend mathematical proofs to cases that are otherwise too tedious and/or specific,<span class="fragment"> and, hopefully, to those (important but) too difficult.</span></li>
					</li>


				</ul>
			</section>




	</div>
	</div>

	<script src="js/reveal.js"></script>


	<script>

		// Full list of configuration options available at:
		// https://github.com/hakimel/reveal.js#configuration
		Reveal.initialize({
			controls: true,
			progress: true,
			history: true,
			center: true,

			transition: 'slide', // none/fade/slide/concave/concave/zoom


			math: {
				mathjax: '../MathJax/MathJax.js',
				//				mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js',
				// mathjax: 'http://cdn.mathjax.org/mathjax/latest/MathJax.js',
				config: 'TeX-AMS_HTML-full' // See http://docs.mathjax.org/en/latest/config-files.html
			},

			// Optional reveal.js plugins
			dependencies: [
				{ src: 'lib/js/classList.js', condition: function () { return !document.body.classList; } },
				{ src: 'plugin/markdown/marked.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
				{ src: 'plugin/markdown/markdown.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
				// { src: '../highlight/highlight.pack.js', async: true, condition: function () { return !!document.querySelector('pre code'); }, callback: function () { hljs.initHighlightingOnLoad(); } },
				{ src: 'plugin/highlight/highlight.js', async: true },
				{ src: 'plugin/zoom-js/zoom.js', async: true },
				{ src: 'plugin/notes/notes.js', async: true },
				{ src: 'plugin/math/math.js', async: true }
			]
		});

		//			Reveal.addEventListener( 'slidechanged', function( event ) {
		//				MathJax.Hub.Rerender();
		//			} );

	</script>

</body>

</html>