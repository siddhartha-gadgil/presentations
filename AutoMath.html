<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Can computers conquer mathematics?</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/moon.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<link rel="icon" href="../IIScLogo.jpg">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

<div class="reveal">

<!-- Any section element inside of this container is displayed as a slide -->
<div class="slides">
<section>
	<h2> Can computers conquer mathematics? </h2>
	<h3> HoTT Foundations, Learning </h3>
	<h2>Siddhartha Gadgil</h2>
	 <p>Department of Mathematics</p>
	 <p>Indian Institute of Science</p>
	 <p>Bangalore</p>
	 <p><a href="https://github.com/siddhartha-gadgil/ProvingGround" target="_blank">https://github.com/siddhartha-gadgil/ProvingGround</a></p>

</section>

<section>
	<section>
		<h3>Theorem Proving:</h3>
		<h3> Enumeration, Computation, Deduction </h3>
		<p>Goals</p>
		<p>Computer-Assisted proof components</p>
		<p>Automated Deduction</p>
		<p> Limits of Set theory and First-order Logic</p>
	</section>
	<section>
		<h3> Goals </h3>
		<ul>
			<li><b> Goal:</b> Use computers to greatly increase our ability to discover and prove
				mathematical results across areas of mathematics.</li>
			<li class="fragment"> Why? </li>
			<li class="fragment"> How? </li>
		</section>
		<section>
			<h3> What? </h3>
			<ul>
				<li class="fragment"> There are infinitely many prime numbers. </li>
				<li class="fragment"> There are arbitrarily long arithmetic sequences all of whose elements are prime numbers. </li>
				<li class="fragment"> There are infinitely many natural numbers $n$ such $n$ and $n+2$ are both primes.</li>
			</ul>
		</section>
	<section>
		<h3> Computer-Assisted proof components </h3>
		<ul>
			<li class="fragment"> Computers have been used in various ways to provide a component of a proof:
				<ul>
					<li> Enumeration, </li>
					<li> Symbolic algebra, </li>
					<li> Exact real number arithmetic, </li>
					<li> Linear programming, </li>
					<li> SAT solvers.</li>
				</ul>
			</li>

			<li class="fragment"> Some examples:
				<ul>
					<li> Four colour theorem, </li>
					<li> Kepler conjecture, </li>
					<li> Boolean Pythagorean triples problem. </li>
				</ul>
			</li>
		</ul>

	</section>

	<section>
	  <h3> First-order logic: languages</h3>
	  <ul>
	  <li class="fragment"> A first-order language, which describes a domain of discourse (e.g. $\mathbb{N}$) has vocabulary consisting of
	    <ul>
	      <li> Variables - can be taken to be a fixed countable set.</li>
	      <li> Constants (e.g. $0$, $1$).</li>
	      <li> Functions  (e.g. $+$).</li>
	      <li> Predicates (e.g. $<$, $=$).</li>
	      <li> Special symbols $\Rightarrow$, $\iff$, $\wedge$, $\vee$, $\forall$, $\exists$, ... </li>
	      </ul>
	    <li class="fragment"> We form two kinds of expressions from these, <em>terms</em> and <em> formulas </em>.</li>
	    <li class="fragment"> Terms and formulas may depend on values of some variables.</li>
	    <li class="fragment"> Terms represent objects in the <em> domain of discourse</em>. </li>
	    <li class="fragment"> Formulas are either <em>true</em> or <em>false</em>. </li>
	    </ul>
	</section>

	<section>
	  <h3> Deduction and theories </h3>
	  <ul>
	    <li class="fragment"> We can deduce formulas from other formulas using the rules of deduction. </li>
	    <li class="fragment"> The main deduction rule is <em> Modus Ponens</em> : given $P$ and $P\Rightarrow Q$ we deduce $Q$.</li>
	    <li class="fragment"> A <em> theory</em> is a language together with a collection of statements, called <em> axioms</em> in the language.</li>
	    <li class="fragment"> A statement is <em> deducible</em> in a theory if it can be obtained from the axioms by the rules of deduction.</li>
	  </ul>
	</section>

	<section>
		<h3> Universal deducer? </h3>
		<ul>
			<li class ="fragment"> An ultimate prover is a function which, given a deducible proposition (formula),
				returns a proof.</li>
			<li class="fragment"> By results of Turing, there is no such function. </li>
			<li class="fragment"> We can enumerate proofs and check if they prove either the given proposition or its negation.
				<span class="fragment"> This does not always work as there are statements that are true but not provable.</span>
			</li>
			 <li class="fragment"> Practically, we can conclude that there is no best deducer,
				 as all proofs can be found but no deducer can find them all. </li>
		</ul>
	</section>

	<section>
		<h3> Resolution theorem proving: Conjunctive normal form </h3>
		<ul>
			<li class ="fragment"> To prove a proposition $P$ from axioms, we can derive a contradiction from $\neg P$ and the axioms.</li>
			<li class ="fragment"> We can rewrite $\implies$ and $\wedge$ in terms of $\vee$ and $\neg$.</li>
			<li class ="fragment"> Suppose a variable is existentially quantified,
				<ul>
				<li class ="fragment"> e.g. $\delta$ in $\forall \epsilon \exists \delta\ |x| < \delta \implies |x|^2 < \epsilon$, </li>
				<li class ="fragment"> we can regard the variable as a function $\delta(\epsilon)$,</li>
				<li class ="fragment"> we extend the language with the additional function/constant.</li>
				<li class ="fragment"> In the extended language we no longer need $\exists$,
					$\forall \epsilon\ |x| < \delta(\epsilon) \implies |x|^2 < \epsilon$. </li>
					<li class="fragment"> Variables without explicit quanitification are regarded as universally quantified.</li>
				</li>
			</ul>

		</ul>

	</section>

	<section>
		<h3> Resolution theorem proving </h3>
			<ul>
			<li class ="fragment"> By the above process, we reduce to
				<ul>
				<li> A sequence of statements, i.e., a conjunction of clauses.</li>
				<li> Each clause consists of atomic formulas and their negations combined by $\vee$,
					i.e., a disjunction of literals. </li>
				</ul>
			</li>
			<li class="fragment"> From these we seek a contradiction - an empty clause.</li>
			<li class ="fragment"> <em>Resolution </em> is the rule by which if two clauses are of the form
				$P\vee Q_1\vee\dots\vee Q_n$ and $\neg P \vee R_1\vee \dots\vee R_m$, we deduce
				$Q_1\vee\dots\vee Q_n\vee R_1\vee \dots\vee R_m$.</li>
			<li class="fragment"> Combined with unification, this is <em> refutation complete</em>.</li>
			<li class="fragment"> To handle equality efficiently, another rule called <em>paramodulation</em> is used.</li>
			</ul>

	</section>

	<section>
		<h3> First-order logic deducers; machine learning</h3>
		<ul>
			<li class="fragment"> Theorem proving is thus reduced to a search for the empty clause,
				starting with a given collection of clauses and using moves such as resolution and paramodulation.</li>
			<li class="fragment"> Various search heuristics can be used. </li>
			<li class="fragment"> We can also add premises corresponding to theorems in a formal library
				(Mizar has been used for this).</li>
			<li	class="fragment"> Machine learning has been used too select both strategies and premises.</li>
			</ul>
	</section>

	<section>
		<h3> Robbins conjecture </h3>
		<ul>
			<li class="fragment"> Robbins conjecture was a conjectural characterization of Boolean algebras in terms of
				associativity and commutativity of $\vee$ and the Robbins equation
				$\neg(\neg(a\vee b)\vee \neg(a \vee \neg b)) = a$.</li>
			<li class="fragment"> This was conjectured in the 1930s, and finally proved in 1996 using the
				automated theorem prover EQP.</li>
			<li class="fragment"> So far, this seems to be the only major success of deductive theorem provers.</li>
			<li class="fragment"> First-order logic theorem provers are, however, used in interactive proof systems
				(hammer tactics). </li>
	</section>

	<section>
		<h3> Real-life mathematics</h3>
		<ul>
			<li class="fragment"> A proof in real-life mathematics consists of:
				<ul>
					<li> definitions, axioms, assumptions, notation; </li>
					<li> assertions; </li>
					<li> hints about which assertions, definitions etc. are used in the proof of a given assertion.</li>
				</ul>
			</li>
			<li class="fragment"> The reader is expected to deduce all assertions based on the hint
				(or at least believe that he/she can do so).</li>
			<li class="fragment"> In particular, there is no objective sense in which a proof is complete or correct.</li>
			<li class="fragment"> Interactive proof systems modelled on human proofs, such as Mizar and Naproche,
				follow a similar approach.</li>
			</ul>
	</section>

	<section>
	  <p>
	    &ldquo; Since the first half of the 20th century mathematics has been presented as a science based on
	    ZFC and ZFC was introduced as a particular theory in Predicate Logic.
	  </p>
	  <p>
	    &ldquo; Therefore someone who wanted to get to the bottom of things in mathematics had a simple
	    road to follow - learn what Predicate Logic is, then learn a particular theory called ZFC, then
	    learn how to translate propositions about a few basic mathematical concepts into formulas of
	    ZFC, and then <span class="fragment highlight-red"> learn to believe, through examples, that the rest of mathematics can be reduced
	    to these few basic concepts</span>.&rdquo;</p>
<div style="text-align:right">Vladimir Voevodsky</div>
	  </section>

	<section>
		<h3> Why new foundations? </h3>
		<ul>
			<li class="fragment"> In the usual foundations of mathematics, $sin(3)$ and $3(sin)$ are syntactically equally valid.
			</li>
			<li class="fragment"> We need additional (runtime) conditions for being well-defined.
			</li>
			<li class="fragment"> We do have types, i.e., syntactic restrictions, in Category theory and Higher-order logic.
			</li>
			<li class="fragment"> However, proofs are still not first class, so not composable.
			</li>
			<li class="fragment"> We instead have patterns of proof (such as induction) in mathematics,
				and tactical meta-language in formal proof systems (which are then implicitly part of the foundations).</li>
			</ul>
	</section>

	<section>
<p>
<q> &ldquo; The roadblock that prevented generations of interested mathematicians and computer scientists
from solving the problem of computer verification of mathematical reasoning was the
unpreparedness of foundations of mathematics for the requirements of this task.&rdquo;</q></p>
<p>
<q> &ldquo; Formulating mathematical reasoning in a language <span style="color:green">precise enough for a computer to follow</span>
meant using a foundational system of mathematics <span class="fragment highlight-blue"> not as a standard of consistency applied only
to establish a few fundamental theorems, but as a tool that can be employed in everyday
mathematical work.</span> &rdquo;</q></p>


<div style="float:right"> Vladimir Voevodsky</div>

	</section>

</section>


<section>
	<section>
		<h3> Martin-L&Oumlf Type theory</h3>
			<p> Type theoretic Foundations</p>
		 	<p>Terms, Types, Rules</p>
		 	<p>Inductive types</p>
		 	<p> Dependent Types</p>
		 	<p>Propositions as types</p>
	</section>
	<section>
		<h3> Type theoretic foundations</h3>
		<ul>
			<li class="fragment"> Mathematical objects, called <em class="fragment highlight-current-blue"> terms</em> have <em class="fragment highlight-current-blue"> types </em>. </li>
			<li class="fragment"> A term $a$ having a type $A$, denoted $a : A$, is analogous to
				an element $a$ belonging to a set $A$, i.e., $a \in A$.</li>
			<li class="fragment"> However the rules for forming terms and types, and for determining
				whether a term has a type, are purely <em class="fragment highlight-current-blue"> syntactic. </em></li>
			<li class="fragment"> Nevertheless, the rules for forming types are rich enough that types can play the role of sets
				<span class="fragment"> - for instance, prime numbers form a type.</span>
			 </li>
			<li class="fragment"> Even more remarkably, propositions and proofs can be expressed in terms of types and terms.
			</li>
		</ul>
	</section>

	<section>
	  <h3> Terms, Types, Rules </h3>
	  <ul>
	  <li class="fragment"> Mathematical objects are called <em class="fragment highlight-current-blue">terms. </em> </li>
	  <li  class="fragment"> Every term has a <em class="fragment highlight-current-blue"> type </em>, generally unique.</li>
	  <li class="fragment"> Types are also terms, whose types are <em class="fragment highlight-current-blue"> universes</em>.</li>
		<li class="fragment"> We have <em class="fragment highlight-current-blue">rules</em> to introduce terms (including types), individually or in groups, into the context.</li>
		<li class="fragment"> Rules also let us make two kinds of <strong>judgements</strong>:
	  	<ul>
				<li> that a term $a$  is of type $A$. </li>
				<li> that two terms are equal <em class="fragment highlight-current-blue"> by definition </em>.
				</ul>
			</li>
			<li class="fragment"> All the rules are syntactic.</em>
	    <li class="fragment">  Note that terms can be equal without being so by definition. </li>
	    <li class="fragment"> There is a relation (type family) <em class="fragment highlight-current-blue"> propositional equality</em> extending definitional equality.</li>
	  </ul>
	  </section>

	<section>
	  <h3> Function types, functions and applications </h3>
	  <ul>
	    <li class="fragment"> Given types $A$ and $B$, we can introduce the function type $A \to B$, whose members are functions.</li>
	    <li class="fragment"> Given $f: A \to B$ and $a : A$, we get a term $f(a) : B$.</li>
	    <div class="fragment">
	      <li> We can construct a function $f: A \to B$ by giving an expression $b$ of type $B$
					in terms of a variable $a : A$ and other terms in the context, i.e., $f : a \mapsto b$.</li>
</div>
	    <li class="fragment"> We can also define functions <em class="fragment highlight-current-blue"> recursively</em> on <em class="fragment highlight-current-blue"> inductive types </em>.</li>
	    </ul>
	</section>


	<section>
	  <h3>  Inductive types</h3>
	  <ul>
			<li class="fragment"> An inductive type $T$
				 is defined by specifying terms (usually functions)
				that construct members of $T$. </li>

<pre class="fragment"><code class="haskell">
data ℕ : Type where
  zero : ℕ
  succ : ℕ → ℕ
</code></pre>
<pre class="fragment"><code class="scala">
sealed class Nat
case object zero extends Nat
case class succ(n: Nat) extends Nat
</code></pre>
	<li class="fragment"> Formally, we are introducing into the context the type $\mathbb{N}$ and two terms $0$ and $succ$.</li>
	<li class="fragment"> The type is <em class="fragment highlight-current-blue"> freely generated</em> by its constructors, allowing recursive
		and inductive definitions.</li>
	    </ul>
	  </section>

	<section>
	  <h3> Recursive definitions </h3>
	  <ul>
	    <li class="fragment"> We can define functions recursively on inductive types, by specifying in all cases.</li>

<div>
<pre class="fragment"><code class="haskell">
_+_ : ℕ → ℕ → ℕ
zero + y = y
(succ x) + y = succ (x + y)
	</code></pre>
<pre class="fragment"><code class="scala">
val sum: Nat => Nat => Nat = {
	  case zero => (m: Nat) => m
	  case succ(n) => (m: Nat) => succ(sum(n)(m))
	}
</code></pre>
</div>
<li class="fragment"> Formally, we can introduce recursion functions and apply them to the definition data. </li>
</ul>
	</section>


	<section>
	  <h3> Dependent functions and type families </h3>
	  <ul>
	    <li class="fragment"> We generalize functions $f : A \to B$ to <em class="fragment highlight-current-blue"> dependent functions</em>, so that $f(a)$ has a type $B(a)$, depending in general on $a : A$.</li>
	    <li class="fragment"> More precisely,
	      <ul>
		<li class="fragment"> A <em class="fragment highlight-current-blue"> type family</em> $B: A \to \mathfrak{U}$ is a function with codomain a universe, so all its values are types. </li>
		<li class="fragment"> Given a type family $B: A \to \mathfrak{U}$, we can construct a corresponding type $\prod_{a : A} B(a)$ of dependent functions.</li>
		<li class="fragment"> We can apply $f : \prod_{a : A} B(a)$ to $a : A$, to obtain $f(a) : B(a)$.</li>
		</ul>
	      </li>
	  <li class="fragment"> Constructions of dependent functions are analogous to those of functions.</li>
	  </ul>
	  </section>

	<section>
	  <h3>Vectors : an inductive type family </h3>
	  <ul>
	    <li class="fragment"> We have a type family associating to each $n : \mathbb{N}$ the type of vectors of length $n$ with entries in a type $A$.</li>
	    <li class="fragment"> This is an inductive type family with two constructors.</li>
<div class="fragment">
<pre><code class="haskell">
data Vector (A : Type) : ℕ → Type where -- inductive type family
  [] : Vector A 0
  _::_ : {n : ℕ} → A → Vector n → Vector (succ n)
</code></pre>
</div>
	    <li class="fragment"> We can define dependent functions to this type family <em class="fragment highlight-current-blue">inductively</em>.</li>
<div class="fragment">
<pre><code class="haskell">
countdown : (n : ℕ) → Vector ℕ n -- dependent function
countdown 0 = []
countdown (succ n) = (succ n) :: (countdown n)
</code></pre>
</div>
	    <li class="fragment"> Formally, we can construct an <em class="fragment highlight-current-blue">induction function</em> and apply it to the data.</li>
	  </ul>
	  </section>

	<section>
	  <h3> Functions on type families </h3>
	  <ul>
	    <li class="fragment"> We can define (dependent) functions on inductive type families recursively (inductively).</li>
	    <li class="fragment"> However, we must define these simultaneously on all types in the inductive type family.</li>
<div class="fragment">
<pre><code class="haskell">
sum : {n : ℕ} → Vector ℕ n → ℕ
sum [] = 0
sum (x :: l) = x + sum l
</code></pre>
</div>
	  </ul>
	  </section>

		<section>
			<h3> Some useful Inductive types</h3>
			<ul>
				<li>
			We can inductively define the types $\mathbb{0}$, $\mathbb{1}$, $A \times B$, $A \oplus B$.</li>
			<li> For a type family $B: A \to \mathcal{U}$, the <em class="fragment highlight-current-blue">dependent pair</em> type $\sum_{a: A} B(a)$
				has terms pairs $(a, b)$ with $b : B(a)$.</li>
	<div class="fragment">
	<pre><code class="haskell">
	data True : Type where
		qed : True

	data False : Type where

	data _×_  (A B : Type) : Type where
		_,_ : A → B → A × B

	data _⊕_  (A B : Type) : Type where
		ι₁ : A → A ⊕ B
		ι₂ : B → A ⊕ B

	data Σ (A : Type) (B : A → Type) : Type where
		_,_ : (a : A) → (B a) → Σ A B
	</code></pre>
	</div>
		</section>


		<section>
			<h3>Propositions as types</h3>
			<ul>
				<li class="fragment">A type $A$ is <em class="fragment highlight-current-blue">inhabited</em> if there is a term $a$ with $a : A$.</li>
				<li class="fragment">By <em class="fragment highlight-current-blue"> propostion</em> we mean a logical statement that must be true or false.</li>
				<li class="fragment">We represent propositions by types.</li>
				<li class="fragment">If a type $A$ is viewed as a proposition, a term $a : A$ is a <em class="fragment highlight-current-blue">proof</em> of (or witness to) $A$.
				<li class="fragment">In particular, a proposition is <strong>true</strong> if and only if the corresponding type is <strong>inhabited</strong>.</li>
				<li class="fragment">Note that we must be able to form types representing propositions of interest in mathematics by the type formation rules.</li>
			</ul>
		</section>

		<section>
			<h3>Combining propositions</h3>
			<p class="fragment"> Let $A$ and $B$ be types, regarded as representing propositions.</p>
			<ul>
				<li class="fragment"> The proposition $A \Rightarrow B$ is represented by $A \to B$.</li>
				<li class="fragment"> The propostion $A\wedge B$ is represented by $A \times B$.</li>
				<li class="fragment"> The proposition $A \vee B$ is represented by $A \oplus B$.</li>
				<li class="fragment"> The proposition $\neg A$ is represented by $A \to \mathbb{0}$.</li>
			</ul>
		</section>

		<section>
			<h3>Quantifying propositions</h3>
			<ul>
				<li class="fragment">A proposition depending on a variable $x : A$ is represented by a type family $P : A \to \mathfrak{U}$. </li>
				<li class="fragment">The proposition $\forall x\ P(x)$ is represented by $\prod_{x: A} P(x)$.</li>
				<li class="fragment">The proposition $\exists x\ P(x)$ is represented by $\sum_{x : A} P(x)$.</li>
			</ul>
		</section>

	<section>
	  <h3> Identity type family</h3>
	  <ul>
	    <li class="fragment"> For a fixed type $A$, propositional equality is given by the identity type family freely generated by reflexivity.</li>
<div class="fragment">
<pre><code class="haskell">
data _==_ {A : Type} : A → A → Type where
  refl : (a : A) → a == a
</code></pre>
</div>
	    <li class="fragment"> This is an inductive type family.</li>

<div class="fragment">
<pre><code class="haskell">
symmetry : {A : Type} → {x y : A} → (x == y) → (y == x)
symmetry (refl a) = refl a

trans : {A : Type} → {x y z : A} → (x == y) → (y == z) → (x == z)
trans (refl a) (refl .a) = refl a
</code></pre>
</div>
	    <li class="fragment"> However, for fixed $a: A$, $a = a$ is <strong> not </strong> an inductive type, i.e., it is not suffiicient to define functions on $refl(a)$.</li>
	  </ul>
	  </section>
</section>


<section>
	<section>
		<h3>Homotopy type theory: Types as Spaces</h3>
		<p> Equality, Paths, Homotopy </p>
		<p> Levels from dimension</p>
		<p> Sets, Propositions</p>
	</section>

	<section>
	  <h3> Types as Spaces </h3>
	  <ul>
	    <li class="fragment"> We <em class="fragment highlight-current-blue">interpret</em>
	      <ul>
		<li class="fragment"> Types as <em class="fragment highlight-blue">spaces</em>. </li>
		<li class="fragment"> Terms of a type as points of the space.</li>
		<li class="fragment"> Functions $A \to B$ as continuous functions $A \to B$.
		<li class="fragment"> For a type $A$ and terms $x, y: A$, the identity type $x = y$ as
			<em class="fragment highlight-blue">paths</em> in $A$ from $x$ to $y$.</li>
	      </ul></li>
	    <li class="fragment"> We do not actually construct spaces, i.e., sets with topology, starting with a type.</li>
	    <li class="fragment"> Instead we make topological (specifically homotopy theoretic) constructions and prove topological results in type theory.</li>
	    <li class="fragment"> A practical consequence for type theories is that we get a canonical, provably consistent, type theory.</li>
	  </ul>
	  </section>

	<section>
	  <h3> Equality, Paths,  Homotopies</h3>
	  <ul>
	    <li class="fragment"> As above, for a type $A$ and $x, y : A$, a term $p : (x = y)$ is interpreted
				as a path from $x$ to $y$.
			</li>
			<li class="fragment"> Two such paths are equal if there is a path of paths, called a homotopy,
				between them.
			</li>
			<img src="HomotopySmall.gif" class="fragment" height = "200"/>
			<img src="Mug_and_Torus_morph.gif" class="fragment" height="200" />
	    <li class="fragment"> We have similar notions of equality for functions.</li>
			<li class="fragment"> Types are equal if the corresponding spaces are homotopy equivalent,
				as a consequence of the <em> Univalence axiom. </em></li>
	  </section>


	<section>
	  <h3> Dimension and levels </h3>
	  <ul>
			<li class="fragment"> We define levels of types, based on a characterization of dimension in homotopy theory.</li>
	    <li class="fragment"> By definition, there is a unique type at level $-2$ (the lowest),
				which has a single term. </li>
	    <li class="fragment"> Inductively, we define the level of a type $A$ to be at most $(n + 1)$
				if for $a, b : X$, the type $a = b$ has level at most $n$.</li>
	    <li class="fragment"> Further, we can truncate a type canonically to an $n$-type.</li>
	    </ul>
	  </section>

	<section>
	  <h3> Sets and mere propositions </h3>
	  <ul>
	    <li class="fragment"> A set is a space with all of its components contractible.</li>
	    <li class="fragment"> A type $A$ is a set if for $x, y: A$ and $p, q: x = y$, we have $p = q$.</li>
	    <li class="fragment"> A mere proposition is a type which is either empty or all of its elements are equal,
				i.e., a type at level $-1$.</li>
	    <li class="fragment"> The concept of mere propostions, as well as propositional truncation,
				allow consistent mixing of classical logic with the type theoretic form.</li>
			<li class="fragment"> For instance, in homotopy type theory the law of excluded middle is usually assumed
				for mere propositions, but not for all types.</li>
	  </section>


		<section>
			<h3> Lean theorem prover </h3>
			<ul>
				<li class="fragment"> In a language like Agda, it is practical to write moderate sized proofs fully formally.</li>
				</li>
				<li class="fragment"> The lean theorem prover allows this, and also has an elaboration engine to help complete proofs efficiently.
				</li>
					<li class="fragment"> Checking a (fully elaborated) proof is fairly easy, and lean has an efficient export format
						and an independent Haskell typechecker to do this.</li>
				<li class="fragment"> The export format, server and API also allow efficient integration with other systems.
				</li>
			</ul>
		</section>

</section>

<section>
	<section>
		<h3> Proving-Ground: Theorem proving by Learning</h3>
		<p> HoTT implemented in Scala </p>
		<p> Reinforcement learning </p>
		<p> Representation learning </p>
		<p> Natural language processing </p>
	</section>

	<section>
		<h3> Reinforcement learning: non-trivial theorems </h3>
		<ul>
			<li class="fragment"> Useful mathematical objects are terms representing useful types.</li>
			<li class="fragment"> Given weights on terms and types,
				non-trivial objects are those representing types of high weight (low complexity)
				 so that the total weight of terms inhabiting the type is low.</li>
			<li class="fragment"> Further, useful theorems are those from which non-trivial theorems are derived.</li>
			<li class="fragment"> These can be captured by considering the map from terms to types, and backward propagating.
			</li>
		</ul>
	</section>

	<section>
		<h3> Reinforcement learning: term-type map </h3>
		<ul>
			<li class="fragment"> Given an initial distribution on terms, rules for forming terms gives a new distribution.</li>
			<li class="fragment"> Given a probability distribution on terms, we get one on types by
				mapping a term to its type (proof distribution). </li>
			<li class="fragment"> As (inhabited) types themselves are terms, we get a restricted distribution on them
				(theorem distribution). </li>
			<li class="fragment"> We have a flow of the proof distribution towards the theorem distribution.</li>
			<li class="fragment"> The gradient gives a distribution on terms, which we backward propagate.</li>
			<li class="fragment"> It is useful to freeze the distribution on terms.</li>
			<li class="fragment"> We may also learn using a distribution from the (formalized) literature.</li>
		</ul>

	</section>

	<section>
		<h3> Representation learning </h3>
		<p> Using proximity and order, words, mathematical objects etc can be represented by vectors
			which capture many of their relations.
		</p>
	</section>

	<section>
		<h3> NLP: extracting from human literature.</h3>
		<ul>
			<li class="fragment"> We try to extract mathematical objects from the literature,
				with reasonably high accuracy. </li>
			<li class="fragment"> These can be used for learning, both giving terms from which to generate others,
				and a distribution on types.</li>
			<li class="fragment"> This is similar to a translation problem, except the target language has
				strong restrictions on sentences being meaningful and true.</li>
			<li class="fragment"> To extract from natural language, we first use a parser to break a sentence into
				a tree like structure.</li>
			</ul>
		</section>

</section>



		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom


				math: {
					mathjax: '../MathJax/MathJax.js',
					// mathjax: 'http://cdn.mathjax.org/mathjax/latest/MathJax.js',
					config: 'TeX-AMS_HTML-full' // See http://docs.mathjax.org/en/latest/config-files.html
				},

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../highlight/highlight.pack.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/math/math.js', async: true}
				]
			});

//			Reveal.addEventListener( 'slidechanged', function( event ) {
//				MathJax.Hub.Rerender();
//			} );

		</script>

	</body>
</html>
