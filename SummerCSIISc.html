<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Automating Mathematics:
	 PolyMath, Type Theory and Learning</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/league.css" id="theme">
		<link rel="stylesheet" href="css/custom.css">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<link rel="icon" href="IIScLogo.jpg">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

<div class="reveal">

<!-- Any section element inside of this container is displayed as a slide -->
<div class="slides">
<section>
	<h2 class="title"> Automating Mathematics: </h2>
	<h2> PolyMath, Type Theory and Learning </h2>
	<p>Department of Mathematics</p>
	 <p>Indian Institute of Science</p>
	 <p>Bangalore</p>
	 <p><a href="https://github.com/siddhartha-gadgil/ProvingGround" target="_blank">https://github.com/siddhartha-gadgil/ProvingGround</a></p>
</section>

<section>
	<h3>Goals</h3>
	<ul>
		<li class="fragment">Equip computers with all the major capabilities
used by Mathematicians and the Mathematics
community in the discovery and proof of
Mathematical results and concepts.</li>
<li class="fragment">Beyond
	experimentation/computation/enumeration.</li>
<li class="fragment">We must have, if necessary invent, objective measures for the different
capabilities.</li>
<li class="fragment">Our attempt is to build a bridge to the highly successful AI systems and concepts: AlphaZero, Reinforcement learning,
Representation learning, Natural Language Processing, GANs etc.</li>

	</ul>
</section>

<section>

	<h2> Homomogeneous length functions on Groups </h2>
	<h2> A PolyMath adventure</h2>


</section>
<section>
		<h3>The PolyMath 14 participants</h3>
		<ul>
			<li>Tobias Fritz, MPI MIS</li>
			<li> Siddhartha Gadgil, IISc, Bangalore </li>
			<li> Apoorva Khare, IISc, Bangalore</li>
			<li>	Pace Nielsen, BYU </li>
			<li> Lior Silberman, UBC </li>
			<li> Terence Tao, UCLA </li>
		</ul>


</section>

<section>
    <ul>
      <li>On Saturday, December 16, 2017, Terrence Tao posted on his blog a question, which Apoorva Khare had asked him.</li>
				<blockquote class="fragment">
					Is there a homogeneous, (conjugacy invariant) length function on the free group on two generators?
				</blockquote>
			<li class="fragment">Six days later, this was answered in a collaboration involving several mathematicians (and a computer).</li>
			<li class="fragment">This the story of the answer and its discovery.</li>
    </ul>
</section>

<section>
	<h3>Length functions</h3>
	<ul>
	  <li class="fragment">Fix a group $G$, i.e. a set with an associative product with inverses.</li>
		<li class="fragment">A <em>pseudo-length function</em> $l: G \to [0, \infty)$ is a function  such that:
			<ul>
				<li>$l(e) = 0$.</li>
				<li>$l(g^{-1}) = l(g)$ , for all $g \in G$.</li>
				<li> (Triangle inequality) $l(gh) \leq l(g) + l(h)$, for all $g,h\in G$.</li>
			</ul>
		</li>
		<li class="fragment">A <em>length function</em> is a pseudo-length function such that $l(g) > 0$ whenever $g\neq e$ (positivity condition).
	</ul>
</section>

<section>
		<ul>
		  <li>A pseudo-length function $l$ is said to be conjugacy invariant if $l(ghg^{-1})=l(h)$ for all $g, h \in G$.</li>
			<li class="fragment">$l$ is  said to be <em>homogeneous</em> if $l(g^n) = nl(g)$ for all $g \in G$. </li>
			<li class="fragment">On the group $\mathbb{Z}^2$ of pairs of integers, a (conjugacy invariant) homogeneous length function is given by $l_{\mathbb{Z}^2}((a,b)) = |a| + |b|$.</li>
		</ul>
</section>

<section>
	<h3>Free group $\mathbb{F}_2$ on $\alpha$, $\beta$</h3>
	<ul>
	  <li class="fragment">Consider words in four letters $\alpha$, $\beta$, $\bar{\alpha}$ and $\bar{\beta}$.</li>
		<li class="fragment">We multiply words by concatenation, e.g. $\alpha\beta\cdot\bar{\alpha}\beta = \alpha\beta\bar{\alpha}\beta$.</li>
		<li class="fragment">Two words are regarded as equal if they can be related by cancellating adjacent letters that are inverses, e.g. $\alpha\beta\bar{\beta}\alpha\beta = \alpha\alpha\beta$.</li>
		<li class="fragment">This gives a group; <span class="fragment"> e.g.
			$(\alpha\bar{\beta}\alpha\beta\beta)^{-1} = \bar{\beta}\bar{\beta}\bar{\alpha}\beta\bar{\alpha}$. </span></li>
		<li class="fragment">Ignoring order of letters in a word $g$ gives an element $\bar{g}=\alpha^k\beta^l\sim (k, l)$  of $\mathbb{Z}^2$; thus we get a pullback homogeneous, conjugacy-invariant pseudo-length on $\mathbb{F}_2$.</li>
	</ul>
</section>



<section>
	<h3>The Main results</h3>
	<ul>
		<li class="fragment"> <strong>Question:</strong> Is there a homogeneous length function on the free group on two generators? </li>
		<li class="fragment"> <strong>Answer:</strong> No; </li>
		<li class="fragment">In fact all homogeneous pseudo-lengths are pullbacks from Abelian groups.</li>
	</ul>
</section>

<section>
	<h3>First reductions</h3>
	<ul>
	  <li class="fragment">(Fritz): Homomogeneous implies Conjugacy invariant.</li>
		<li class="fragment">(Tao, Khare): $l(g^2) = 2l(g) \forall g\in G$ implies Homogeneity.</li>
	</ul>
</section>

<section>
	<h3>Finding bounds: contradict positivity?</h3>
	<ul>
	  <li class="fragment">Fix $l$ homomogeneous pseudo-length function.
			<li class="fragment">The triangle inequality gives bounds on $l(gh)$ in terms of $l(g)$ and $l(h)$.</li>
			<li class="fragment">Homogeneity gives a bound on $l(g)$ in terms of a bound on $l(g^n)$; also use conjugacy invariance.</li>
			<li class="fragment">Find bounds for elements in terms of bounds for others, especially
				<ul>
				<li class="fragment highlight-current-blue">$l([x, y])$ in terms of $l(x)$ and $l(y)$</li>
				<li class="fragment highlight-current-blue">$l(g)$ for fixed $g$ in terms of bounds on generators.</li>
			</ul>
			</li>
			<li class="fragment">Combine bounds, including by interpreting in terms of convexity.</li>
		</li>

	</ul>
</section>

<section>
	<h3>Seeking a homogeneous length function</h3>
	<ul>
		<li class="fragment">We can attempt to construct pseudo-lengths that are positive, or at least such that $l([\alpha, \beta])> 0$.</li>
	  <li class="fragment">Can consider quotients larger than $\mathbb{Z}^2$: negative results by Sawin, Silberman, Tao. </li>
		<li class="fragment">There were also attempted constructions based on functional analysis.</li>
		<li class="fragment">Given a candidate $l: G \to [0, \infty)$, try to fix this
			using <em>homogenizations</em> and the <em>Kobayashi construction</em>.
		</li>
		<li class="fragment">I hoped to combine these with an approach based on <em>non-crossing matchings</em>.</li>
	</ul>
</section>


<section id="non-cross">
	<h3>Non-crossing matchings</h3>

	 <img src="aabab.png" scale="20%" style="border:none; background-color: white;">
	 <ul>
		 <li class="fragment">Given a word in $\mathbb{F}_2$, we consider <em>matchings</em> such that
		 <ul>
		 	<li class="fragment highlight-current-blue">letters are paired with their inverses,</li>
			<li class="fragment highlight-current-blue">there are no <em>crossings</em></li>
		 </ul>
	 	</li>
		<li class="fragment"> The norm is the number of unmatched letters.</li>
	</ul>
</section>
<section>
	<ul>
		<li>For $g\in \mathbb{F}_2$, define the <span class="fragment highlight-current-blue">Watson-Crick length</span> $l^{}_{WC}(g)$
			 to be the minimum number of unmatched letters over all non-crossing matchings.</li>
		<li class="fragment">$l^{}_{WC}$ is
			<span class="fragment highlight-current-blue"> unchanged under cancellation (hence well-defined on $\mathbb{F}_2$)</span> and
			<span class="fragment highlight-current-blue">conjugacy invariant.</span></li>
			<li class="fragment">It is in fact the maximal conjugacy-invariant length function with generators having length at most $1$.</li>
		<li class="fragment">However, if $g=\alpha[\alpha, \beta]$, then
			<span class="fragment highlight-current-blue">$l^{}_{WC}(g^2)= 4$, but</span>
			<span class="fragment highlight-current-blue">$l^{}_{WC}(g) = 3$,</span> violating homogeneity.
		 </li>
	</ul>
</section>

<section>
	<h3>The great bound chase</h3>
	<ul>
	  <li class="fragment">By Tuesday morning, most people were convinced that there are no homogeneous length functions on the free group.</li>
		<li class="fragment">There was a steady improvements in the combinatorial/analytic bounds on $l([\alpha, \beta])$.</li>
		<li class="fragment">These seemed to be stuck above 1 (as observed by Khare) - but eventually broke this barrier (work of Fritz, Khare, Nielsen, Silberman, Tao).</li>
		<li class="fragment">At this stage, my approach diverged.</li>
	</ul>
</section>


<section>
		<h3>Computer Assisted proving</h3>
	<ul>
		<li class="fragment"> We can recursively compute the matching length $l^{}_{WC}(g)$ for a word $g$.</li>
		<li class="fragment"> This gives an upper bound on all conjugacy-invariant normalized lengths.</li>
		<li class="fragment"> This can be combined with using homogenity.</li>
		<li class="fragment"> Using this, I obtained an upper bound of about $0.85$ on $l(\alpha, \beta)$.</li>
		<li class="fragment"> This was upgraded to a (computer) checkable proof.</li>
		<li class="fragment"> On Thursday morning, I <a href="gross-proof.html">posted</a> an in principle human readable proof of a bound. </li>
	</ul>
</section>
<section id="gross">
	<embed src="gross-proof.html" width="1000" height="600">
</section>

<section>
	<ul>
		<li>The computer-generated proof was studied by Pace Nielsen, who extracted the <em>internal repetition</em> trick. </li>
		<li class="fragment"data-fragment-index="1">This was extended by Nielsen and Fritz and generalized by Tao; from this Fritz obtained the key lemma:
		</li>
		<li class="fragment" data-fragment-index="2">Let $f(m, k) = l(x^m[x, y]^k)$. Then
			$f(m, k) \leq\frac{f(m-1, k) + f(m+1, k-1)}{2}$,
			<span class="fragment" data-fragment-index="4"> i.e., if $Y=\pm 1$ each with probablity $1/2$, $f(m, k) \leq E(f( (m, k - 1/2) + Y(1, -1/2) ))$.</span>
		</li>
		<li class="fragment" data-fragment-index="3">A probabilistic argument of Tao finished the proof.</li>
	</ul>
</section>

<section>
	<h2> The Gross Proof and Beyond </h2>
</section>

<section>
	<h3>Computing bounds and proofs</h3>
	<ul>
	  <li class="fragment">For $g=ah$, $a \in \{\alpha, \beta, \bar{\alpha}, \bar{\beta}\}$, the length $l^{}_{WC}(g)$ is the minimum of:
			<ul>
				<li class="fragment highlight-current-blue">$1 + l^{}_{WC}(h)$ : corresponding to $a$ unmatched.</li>
				<li class="fragment highlight-current-blue">$\min\{l^{}_{WC}(x) + l^{}_{WC}(y): h = x\bar{a}y \}$.</li>
			</ul>
		</li>
		<li class="fragment">We can describe a minimal non-crossing matching by a similar recursive definition.</li>
		<li class="fragment">A similar recursion gives a <em class="fragment highlight-current-blue">proof</em> of a bound on $l(g)$ for $g$ a homogeneous, conjugacy-invariant length with $l(\alpha)=l(\beta)=1$.</li>
		<li class="fragment"> We can also use homogeneity for selected elements and powers to bound the length function $l$.</li>
	</ul>
</section>


<section>
<p>A Type for Proofs of $l(word)\leq bound$</p>
<pre><code class="hljs language-scala scrollcode">sealed abstract class LinNormBound(val word: Word,val bound: Double)

final case class Gen(n: Int) extends LinNormBound(Word(Vector(n)), 1)

final case class ConjGen(n: Int,pf: LinNormBound) extends
  LinNormBound(n +: pf.word :+ (-n), pf.bound)

final case class Triang(pf1: LinNormBound, pf2: LinNormBound) extends
    LinNormBound( pf1.word ++ pf2.word, pf1.bound + pf2.bound)

final case class PowerBound(base: Word, n: Int, pf: LinNormBound) extends
    LinNormBound(base, pf.bound/n){require(pf.word == base.pow(n))}

final case object Empty extends LinNormBound(Word(Vector()), 0)
</code></pre>
</section>

<section>
	<h3>Domain Specific Foundations</h3>
	<ul>
	  <li class="fragment">We defined a scala type (<em>class</em>) and its subtypes.</li>
		<li class="fragment">Objects of this type are proofs of bounds.</li>
		<li class="fragment">The only way to construct such objects of this type is by constructors of its subtypes (<em>case classes</em>).</li>
		<li class="fragment">A proof of a bound for conjugacy invariant length functions is correct iff it <strong>typechecks</strong> (i.e. compiles).</li>
		<li class="fragment">We need to load (i.e. run) to check proofs using homogenity, as also to see what is proved.</li>
		<li class="fragment">This is inspired by <em>Propostions as Types</em> in <em>Dependent Type Theories</em>. </li>
	</ul>
</section>

<section>
	<h3>Merits of the computer proof</h3>
	<ul>
		<li class="fragment"> Our proofs, and their correctness are self-contained, and separate from the act of finding the proof.</li>
		<li class="fragment"> Hence the correctness of the proof depended only on the correctness of the code defining proofs, <span class="fragment highlight-current-blue">which was tiny</span>.</li>
		<li class="fragment"> Further, while the proof was large, the search space for the proof was enormous.</li>
		<li class="fragment"> Hence the proof had information content beyond establishing the truth of a statement.</li>
		<li class="fragment"> In particular, one can learn from such a proof.</li>
	</ul>
</section>
<section>
	<h3>Limitations of the computer proof</h3>
	<ul>
	  <li class="fragment"> The elements for which we applied homogeneity were selected by hand.</li>
		<li class="fragment">More importantly, in our representations of proofs, the bounds were only for concrete group elements.</li>
		<li class="fragment">In particular, we cannot
			<ul>
				<li class="fragment highlight-current-blue">represent inequalities for expressions.</li>
				<li class="fragment highlight-current-blue">use induction. </li>
		</ul>
		<li class="fragment">Would want proof in complete foundations - which I <a href="formal-proof.html">formalized</a> a few days after the PolyMath proof.</li>
	</ul>
</section>

<section id="formal">
	<embed src="formal-proof.html" width="1000" height="600">
</section>

<section>
	<h3>Discovering proofs?</h3>
	<ul>
	  <li class="fragment">If a proof can be represented, it can in principle
		 be discovered by a tree search.</li>
		 <li class="fragment">In practice, there is a combinatorial explosion unless
		 we are selective while branching.</li>
		 <li class="fragment">A good way to tree-search in mathematics is to look for <em>good </em> intermediate lemmas.</li>
		 <li class="fragment">We consider an example problem: given a set $M$ with a multiplication $mul$ and
		 left and right identitites $e_l$ and $e_r$, deduce $e_l=e_r$.</li>
	</ul>
</section>

<section>
	<h3>Underlying Theory</h3>
	<ul>
	  <li class="fragment">We have to explain:
			<ul>
			  <li class="fragment highlight-current-blue">The philosophy behind the domain specific foundations.</li>
				<li class="fragment highlight-current-blue">What we mean by the formalized proof.</li>
				<li class="fragment highlight-current-blue">What is a good lemma.</li>
			</ul>
		</li>
		<li class="fragment">These are all based on (Homotopy) Type Theoretic foundations of mathematics.</li>
	</ul>
</section>

<section>
	<h2>(Homotopy) Type Theory</h2>
</section>

<section>
	<h3>Type Systems, Type Theories, Parts of Speech</h3>
	<ul>
	  <li class="fragment">Statements/expressions/phrases in Programming Languages/Logical Systems/Natural languages are formed
		from simpler ones using the rules of syntax.</li>
		<li class="fragment">The rules of syntax are determined by the types/parts-of-speech of the sub-expressions.</li>
		<li class="fragment">In natural language, simple type systems and first-order logic, the set of types is fixed.</li>
		<li class="fragment"> In most programming languages and in Higher-order logic, we have <em>type forming rules,</em> allowing types to be formed from other types.</li>
	</ul>
</section>

<section>
	<h3>Some Types and Rules</h3>
	<ul>
	  <li class="fragment">Given types $A$ and $B$, we can form the type of functions $A \to B$.</li>
		<li class="fragment"> The types $\mathbb{0}$ has no terms .</li>
		<li class="fragment"> The type $\mathbb{1}$ has a single term $*$.</li>
		<li class="fragment"> The product type $A \times B$ has terms (corresponding to)
			pairs $(a, b)$ with $a: A$ and $b : B$.</li>
		<li class="fragment"> The sum (disjoint union) type $A \oplus B$ has terms (corresponding to) terms of $A$ and terms of $B$.</li>
		<li class="fragment"> Most types we form are <em>inductive types</em> - in scala this is the <em>sealed trait/class</em> and <em>case class</em> construction. </li>
	</ul>
</section>

<section>
	<h3>Dependent type theories</h3>
	<ul>
	  <li class="fragment">In a <em>Dependent type theory/system</em>, types are themselves <em>first-class citizens.</em> </li>
		<li class="fragment">This means they can be argument and results of functions, assigned to variables etc.</li>
		<li class="fragment">Type forming rules can involve terms (objects), for example vectors of length $n$ form a type $Vec(A)(n)$.</li>
		<li class="fragment">Types themselves have types, called universes $\mathfrak{U}$.</li>
		<li class="fragment">A function $P: A \to \mathfrak{U}$ to a universe is called a <em>type family.</em> </li>
	</ul>
</section>

<section>
	<h3>Dependent functions and dependent pairs</h3>
	<ul>
		<li class="fragment">In dependent type theory, we generalize functions to <em>dependent functions</em> with codomain
			$P: A \to \mathfrak{U}$.</li>
		<li class="fragment">The type of dependent functions is $\Pi_{a: A} P(a)$.</li>
		<li class="fragment">If $a: A$ and $f: \Pi_{a: A} P(a)$, we can form $f(a) : P(a)$.</li>
		<li class="fragment">We can also form the type $\Sigma_{a: A} P(a)$ of <em>dependent pairs</em> $(a : A, b : P(a))$.</li>
		<li class="fragment">Dependent pairs, Vectors etc. are  <em>inductive types.</em></li>

	</ul>
</section>

<section>
	<h3>Propositions as types</h3>
	<ul>
		<li class="fragment">A type $A$ is <em>inhabited</em> if there is a term $a$ with $a : A$.</li>
		<li class="fragment">By <em> propostion</em> we mean a logical statement that must be true or false.</li>
		<li class="fragment">We represent propositions by types.</li>
		<li class="fragment">If a type $A$ is viewed as a proposition, a term $a : A$ is a <em class="fragment highlight-current-blue">proof</em> of (or witness to) $A$.
		<li class="fragment">In particular, a proposition is <strong>true</strong> if and only if the corresponding type is <strong>inhabited</strong>.</li>
		<li class="fragment">Note that we must be able to form types representing mathematical propositions by the type formation rules.</li>
	</ul>
</section>

<section>
	<h3>Combining propositions</h3>
	<ul>
		<p class="fragment"> Let $A$ and $B$ be types, regarded as representing propositions.</p>
		<li class="fragment"> The proposition $A \Rightarrow B$ is represented by $A \to B$.</li>
		<li class="fragment"> The propostion $A\wedge B$ is represented by $A \times B$.</li>
		<li class="fragment"> The proposition $A \vee B$ is represented by $A \oplus B$.</li>
		<li class="fragment"> The proposition $\neg A$ is represented by $A \to \mathbb{0}$.</li>
	</ul>
</section>

<section>
	<h3>Quantifying propositions</h3>
	<ul>
		<li class="fragment">A proposition depending on a variable $x : A$ is represented by a type family
			$P : A \to \mathfrak{U}$. </li>
		<li class="fragment">The proposition $\forall x\in A,\ P(x)$ is  $\prod_{x: A} P(x)$.</li>
		<li class="fragment">The proposition $\exists x\in A,\ P(x)$ is  $\sum_{x : A} P(x)$.</li>
	</ul>
</section>


<section>
		<h3> Type theoretic foundations</h3>
		<ul>
			<li class="fragment"> A Type theory is a type system rich enough to replace
				Set Theory + FOL as foundations for mathematics.</li>
			<li class="fragment"> A term $a$ having a type $A$, denoted $a : A$, is analogous to
				an element $a$ belonging to a set $A$, i.e., $a \in A$.</li>
			<li class="fragment"> Rules for forming terms and types, and for determining
				types, are purely <em class="fragment highlight-current-blue"> syntactic. </em></li>
			<li class="fragment"> Nevertheless, the rules for forming types are rich enough that types can play the role of sets
				<span class="fragment"> - for instance, prime numbers form a type.</span>
			 </li>
			<li class="fragment"> Even more remarkably, propositions and proofs can be expressed in terms of types and terms.
			</li>
		</ul>
	</section>

	<section>
		<h2>The Proving-Ground Project</h2>
	</section>

	<section>
		<h3>Contributors</h3>
		<ul>
			<li>Dymtro Mitin</li>
			<li>Tomoaki Hashizaki</li>
			<li>Olivier Roland</li>
			<li>Sayantan Khan</li>
		</ul>
	</section>

	<section>
		<h3>Homotopy Type Theory in Scala</h3>
		<ul>
		  <li class="fragment">We have implemented homotopy type theory in the scala programming language.</li>
			<li class="fragment">The scala types of terms bound the HoTT types in a useful way.</li>
			<li class="fragment"> Symbolic algebra is incorporated by allowing scala objects
			 to represent HoTT terms.</li>
		</ul>
	</section>

	<section>
			<h3> Useful theorems and proofs </h3>
			<ul>
				<li class="fragment"> A theorem with a simple statement but difficult proof is useful.</li>
				<li class="fragment"> A theorem used to prove many other theorems is useful.</li>
				<li class="fragment"> Particularly for applications, we may have an externally determined
					notion of <em>a priori</em> usefulness.</li>
				<li class="fragment"> With Homotopy Type Theory, and Machine learning techniques such as backward propagation, all these
					can be naturally captured; <span class="fragment">we can also capture relationships between mathematical objects.</span> </li>
			</ul>
		</section>



		<section>
			<h3> Reinforcement learning: term-type map </h3>
			<ul>
				<li class="fragment"> Given an initial distribution $P_0$ on terms, rules for forming terms recursively gives a new distribution e.g.
						$$P = \alpha P_0 + \beta \mu_*(P) + \gamma \theta_*(P \times P) + \dots$$
					</li>
				<li class="fragment"> A probability distribution on terms
					 gives one on types by
					mapping  (proof distribution). </li>
				<li class="fragment"> As (inhabited) types themselves are terms, we get a restricted distribution
					(theorem distribution). </li>
				<li class="fragment"> We can compare these to get a relative entropy.</li>
				<li class="fragment"> We also have a (entropy based) cost associated to the generative model.</li>

			</ul>

		</section>

		<section>
			<h3> Exploration, Learning, Representations </h3>
			<ul>
			  <li class="fragment">A <em>good lemma</em> is one where the gain in relative entropy exceeds the cost in generation.</li>
				<li class="fragment">We will use gradient flows and backward propagation to learn generating systems.</li>
				<li class="fragment"> The distribution on theorems can have other components from goals, backward reasoning, external literature etc.</li>
				<li class="fragment"> We will use not just  probabilities but vectors for terms -
				these capture relations, analogies etc.</li>
				<li class="fragment">We also plan to use formalized mathematics and the mathematical literature for learning.</li>
			</ul>

		</section>

<section>
	<h3>From the Lean Theorem Prover</h3>
	<pre>
		<code class="language-scala scrollcode">
package provingground.library
import provingground._
import HoTT._
import induction._
import implicits._
import shapeless._
import Fold._
object nat$decidable_eq {
  val value = lambda("'ag_1531296106_1367828936" :: "nat" :: Type)(({
    val rxyz = pprodInd.value(piDefn("'aj_117702620" :: "nat" :: Type)(("decidable" :: FuncTyp(Prop, Type))(("eq" :: piDefn("'c_751289559" :: Type)(FuncTyp("'c_751289559" :: Type, FuncTyp("'c_751289559" :: Type, Prop))))("nat" :: Type)("'ag_1531296106_1367828936" :: "nat" :: Type)("'aj_117702620" :: "nat" :: Type))))(({
      val rxyz = natInd.value.rec(Type)
      rxyz
    })("punit" :: Type)(lmbda("'h_159188406_990306052" :: "nat" :: Type)(lmbda("'i_854809894_325907817" :: Type)(("pprod" :: FuncTyp(Type, FuncTyp(Type, Type)))(("pprod" :: FuncTyp(Type, FuncTyp(Type, Type)))(piDefn("'aj_482846896" :: "nat" :: Type)(("decidable" :: FuncTyp(Prop, Type))(("eq" :: piDefn("'c_2112253922" :: Type)(FuncTyp("'c_2112253922" :: Type, FuncTyp("'c_2112253922" :: Type, Prop))))("nat" :: Type)("'h_159188406_990306052" :: "nat" :: Type)("'aj_482846896" :: "nat" :: Type))))("'i_854809894_325907817" :: Type))("punit" :: Type))))("'ag_1531296106_1367828936" :: "nat" :: Type)).rec(piDefn("'aj_228954873" :: "nat" :: Type)(("decidable" :: FuncTyp(Prop, Type))(("eq" :: piDefn("'c_1303348173" :: Type)(FuncTyp("'c_1303348173" :: Type, FuncTyp("'c_1303348173" :: Type, Prop))))("nat" :: Type)("'ag_1531296106_1367828936" :: "nat" :: Type)("'aj_228954873" :: "nat" :: Type))))
    rxyz
  })(lmbda("'s_318103601_490050232" :: piDefn("'aj_15078438_215709177" :: "nat" :: Type)(("decidable" :: FuncTyp(Prop, Type))(("eq" :: piDefn("'c_517841910" :: Type)(FuncTyp("'c_517841910" :: Type, FuncTyp("'c_517841910" :: Type, Prop))))("nat" :: Type)("'ag_1531296106_1367828936" :: "nat" :: Type)("'aj_15078438_215709177" :: "nat" :: Type))))(lmbda("_" :: ({
    val rxyz = natInd.value.rec(Type)
    rxyz
  })("punit" :: Type)(lmbda("'h_159188406_753078297" :: "nat" :: Type)(lmbda("'i_854809894_590543722" :: Type)(("pprod" :: FuncTyp(Type, FuncTyp(Type, Type)))(("pprod" :: FuncTyp(Type, FuncTyp(Type, Type)))(piDefn("'aj_1051336192" :: "nat" :: Type)(("decidable" :: FuncTyp(Prop, Type))(("eq" :: piDefn("'c_704808476" :: Type)(FuncTyp("'c_704808476" :: Type, FuncTyp("'c_704808476" :: Type, Prop))))("nat" :: Type)("'h_159188406_753078297" :: "nat" :: Type)("'aj_1051336192" :: "nat" :: Type))))("'i_854809894_590543722" :: Type))("punit" :: Type))))("'ag_1531296106_1367828936" :: "nat" :: Type))("'s_318103601_490050232" :: piDefn("'aj_15078438_215709177" :: "nat" :: Type)(("decidable" :: FuncTyp(Prop, Type))(("eq" :: piDefn("'c_517841910" :: Type)(FuncTyp("'c_517841910" :: Type, FuncTyp("'c_517841910" :: Type, Prop))))("nat" :: Type)("'ag_1531296106_1367828936" :: "nat" :: Type)("'aj_15078438_215709177" :: "nat" :: Type))))))(({
    val rxyz = natInd.value.induc(lmbda("'v_1087445862_593085322" :: "nat" :: Type)(("pprod" :: FuncTyp(Type, FuncTyp(Type, Type)))(piDefn("'aj_202430491" :: "nat" :: Type)(("decidable" :: FuncTyp(Prop, Type))(("eq" :: piDefn("'c_374127766" :: Type)(FuncTyp("'c_374127766" :: Type, FuncTyp("'c_374127766" :: Type, Prop))))("nat" :: Type)("'v_1087445862_593085322" :: "nat" :: Type)("'aj_202430491" :: "nat" :: Type))))(({
      val rxyz = natInd.value.rec(Type)
      rxyz
    })("punit" :: Type)(lmbda("'h_159188406_283972159" :: "nat" :: Type)(lmbda("'i_854809894_765942027" :: Type)(("pprod" :: FuncTyp(Type, FuncTyp(Type, Type)))(("pprod" :: FuncTyp(Type, FuncTyp(Type, Type)))(piDefn("'aj_362557726" :: "nat" :: Type)(("decidable" :: FuncTyp(Prop, Type))(("eq" :: piDefn("'c_187883991" :: Type)(FuncTyp("'c_187883991" :: Type, FuncTyp("'c_187883991" :: Type, Prop))))("nat" :: Type)("'h_159188406_283972159" :: "nat" :: Type)("'aj_362557726" :: "nat" :: Type))))("'i_854809894_765942027" :: Type))("punit" :: Type))))("'v_1087445862_593085322" :: "nat" :: Type))))
    rxyz
  })(("pprod.mk" :: piDefn("'f_858730760" :: Type)(piDefn("'g_84737018" :: Type)(FuncTyp("'f_858730760" :: Type, FuncTyp("'g_84737018" :: Type, ("pprod" :: FuncTyp(Type, FuncTyp(Type, Type)))("'f_858730760" :: Type)("'g_84737018" :: Type))))))(piDefn("'aj_1405500650" :: "nat" :: Type)(("decidable" :: FuncTyp(Prop, Type))(("eq" :: piDefn("'c_1679528951" :: Type)(FuncTyp("'c_1679528951" :: Type, FuncTyp("'c_1679528951" :: Type, Prop))))("nat" :: Type)("nat.zero" :: "nat" :: Type)("'aj_1405500650" :: "nat" :: Type))))("punit" :: Type)(lambda("'ak_992690145_66345703" :: "nat" :: Type)(({
    val rxyz = natInd.value.induc(lmbda("$vuyd_613901509_1138574320" :: "nat" :: Type)(("decidable" :: FuncTyp(Prop, Type))(("eq" :: piDefn("'c_51816028" :: Type)(FuncTyp("'c_51816028" :: Type, FuncTyp("'c_51816028" :: Type, Prop))))("nat" :: Type)("nat.zero" :: "nat" :: Type)("$vuyd_613901509_1138574320" :: "nat" :: Type))))
    rxyz
  })("_" :: ("decidable" :: FuncTyp(Prop, Type))(("eq" :: piDefn("'c_1616709371" :: Type)(FuncTyp("'c_1616709371" :: Type, FuncTyp("'c_1616709371" :: Type, Prop))))("nat" :: Type)("nat.zero" :: "nat" :: Type)("nat.zero" :: "nat" :: Type)))(lambda("'k_621156251_206574004" :: "nat" :: Type)(lmbda("_" :: ("decidable" :: FuncTyp(Prop, Type))(("eq" :: piDefn("'c_1547408363" :: Type)(FuncTyp("'c_1547408363" :: Type, FuncTyp("'c_1547408363" :: Type, Prop))))("nat" :: Type)("nat.zero" :: "nat" :: Type)("'k_621156251_206574004" :: "nat" :: Type)))("_" :: ("decidable" :: FuncTyp(Prop, Type))(("eq" :: piDefn("'c_2022960021" :: Type)(FuncTyp("'c_2022960021" :: Type, FuncTyp("'c_2022960021" :: Type, Prop))))("nat" :: Type)("nat.zero" :: "nat" :: Type)(("nat.succ" :: FuncTyp("nat" :: Type, "nat" :: Type))("'k_621156251_206574004" :: "nat" :: Type))))))("'ak_992690145_66345703" :: "nat" :: Type)))("punit.star" :: "punit" :: Type))(lambda("'v_256405719_429396927" :: "nat" :: Type)(lmbda("'w_566843556_179354281" :: ("pprod" :: FuncTyp(Type, FuncTyp(Type, Type)))(piDefn("'aj_257559038" :: "nat" :: Type)(("decidable" :: FuncTyp(Prop, Type))(("eq" :: piDefn("'c_265527310" :: Type)(FuncTyp("'c_265527310" :: Type, FuncTyp("'c_265527310" :: Type, Prop))))("nat" :: Type)("'v_256405719_429396927" :: "nat" :: Type)("'aj_257559038" :: "nat" :: Type))))(({
    val rxyz = natInd.value.rec(Type)
    rxyz
  })("punit" :: Type)(lmbda("'h_159188406_696790367" :: "nat" :: Type)(lmbda("'i_854809894_317859634" :: Type)(("pprod" :: FuncTyp(Type, FuncTyp(Type, Type)))(("pprod" :: FuncTyp(Type, FuncTyp(Type, Type)))(piDefn("'aj_1612878706" :: "nat" :: Type)(("decidable" :: FuncTyp(Prop, Type))(("eq" :: piDefn("'c_479764664" :: Type)(FuncTyp("'c_479764664" :: Type, FuncTyp("'c_479764664" :: Type, Prop))))("nat" :: Type)("'h_159188406_696790367" :: "nat" :: Type)("'aj_1612878706" :: "nat" :: Type))))("'i_854809894_317859634" :: Type))("punit" :: Type))))("'v_256405719_429396927" :: "nat" :: Type)))(("pprod.mk" :: piDefn("'f_1605051863" :: Type)(piDefn("'g_1443604027" :: Type)(FuncTyp("'f_1605051863" :: Type, FuncTyp("'g_1443604027" :: Type, ("pprod" :: FuncTyp(Type, FuncTyp(Type, Type)))("'f_1605051863" :: Type)("'g_1443604027" :: Type))))))(piDefn("'aj_320897960" :: "nat" :: Type)(("decidable" :: FuncTyp(Prop, Type))(("eq" :: piDefn("'c_1411998825" :: Type)(FuncTyp("'c_1411998825" :: Type, FuncTyp("'c_1411998825" :: Type, Prop))))("nat" :: Type)(("nat.succ" :: FuncTyp("nat" :: Type, "nat" :: Type))("'v_256405719_429396927" :: "nat" :: Type))("'aj_320897960" :: "nat" :: Type))))(("pprod" :: FuncTyp(Type, FuncTyp(Type, Type)))(("pprod" :: FuncTyp(Type, FuncTyp(Type, Type)))(piDefn("'aj_138014301" :: "nat" :: Type)(("decidable" :: FuncTyp(Prop, Type))(("eq" :: piDefn("'c_2131675862" :: Type)(FuncTyp("'c_2131675862" :: Type, FuncTyp("'c_2131675862" :: Type, Prop))))("nat" :: Type)("'v_256405719_429396927" :: "nat" :: Type)("'aj_138014301" :: "nat" :: Type))))(({
    val rxyz = natInd.value.rec(Type)
    rxyz
  })("punit" :: Type)(lmbda("'h_159188406_1856699345" :: "nat" :: Type)(lmbda("'i_854809894_883946601" :: Type)(("pprod" :: FuncTyp(Type, FuncTyp(Type, Type)))(("pprod" :: FuncTyp(Type, FuncTyp(Type, Type)))(piDefn("'aj_1842985757" :: "nat" :: Type)(("decidable" :: FuncTyp(Prop, Type))(("eq" :: piDefn("'c_1398049368" :: Type)(FuncTyp("'c_1398049368" :: Type, FuncTyp("'c_1398049368" :: Type, Prop))))("nat" :: Type)("'h_159188406_1856699345" :: "nat" :: Type)("'aj_1842985757" :: "nat" :: Type))))("'i_854809894_883946601" :: Type))("punit" :: Type))))("'v_256405719_429396927" :: "nat" :: Type)))("punit" :: Type))(lambda("'ak_992690145_1869838569" :: "nat" :: Type)(({
    val rxyz = natInd.value.induc(lmbda("$vuyd_613901509_1095799675" :: "nat" :: Type)(("decidable" :: FuncTyp(Prop, Type))(("eq" :: piDefn("'c_2017105073" :: Type)(FuncTyp("'c_2017105073" :: Type, FuncTyp("'c_2017105073" :: Type, Prop))))("nat" :: Type)(("nat.succ" :: FuncTyp("nat" :: Type, "nat" :: Type))("'v_256405719_429396927" :: "nat" :: Type))("$vuyd_613901509_1095799675" :: "nat" :: Type))))
    rxyz
  })("_" :: ("decidable" :: FuncTyp(Prop, Type))(("eq" :: piDefn("'c_1559678193" :: Type)(FuncTyp("'c_1559678193" :: Type, FuncTyp("'c_1559678193" :: Type, Prop))))("nat" :: Type)(("nat.succ" :: FuncTyp("nat" :: Type, "nat" :: Type))("'v_256405719_429396927" :: "nat" :: Type))("nat.zero" :: "nat" :: Type)))(lambda("'k_217786156_1059286668" :: "nat" :: Type)(lmbda("_" :: ("decidable" :: FuncTyp(Prop, Type))(("eq" :: piDefn("'c_998126858" :: Type)(FuncTyp("'c_998126858" :: Type, FuncTyp("'c_998126858" :: Type, Prop))))("nat" :: Type)(("nat.succ" :: FuncTyp("nat" :: Type, "nat" :: Type))("'v_256405719_429396927" :: "nat" :: Type))("'k_217786156_1059286668" :: "nat" :: Type)))("_" :: ("decidable" :: FuncTyp(Prop, Type))(("eq" :: piDefn("'c_590214278" :: Type)(FuncTyp("'c_590214278" :: Type, FuncTyp("'c_590214278" :: Type, Prop))))("nat" :: Type)(("nat.succ" :: FuncTyp("nat" :: Type, "nat" :: Type))("'v_256405719_429396927" :: "nat" :: Type))(("nat.succ" :: FuncTyp("nat" :: Type, "nat" :: Type))("'k_217786156_1059286668" :: "nat" :: Type))))))("'ak_992690145_1869838569" :: "nat" :: Type)))(("pprod.mk" :: piDefn("'f_14519285" :: Type)(piDefn("'g_88262494" :: Type)(FuncTyp("'f_14519285" :: Type, FuncTyp("'g_88262494" :: Type, ("pprod" :: FuncTyp(Type, FuncTyp(Type, Type)))("'f_14519285" :: Type)("'g_88262494" :: Type))))))(("pprod" :: FuncTyp(Type, FuncTyp(Type, Type)))(piDefn("'aj_161697836" :: "nat" :: Type)(("decidable" :: FuncTyp(Prop, Type))(("eq" :: piDefn("'c_257271152" :: Type)(FuncTyp("'c_257271152" :: Type, FuncTyp("'c_257271152" :: Type, Prop))))("nat" :: Type)("'v_256405719_429396927" :: "nat" :: Type)("'aj_161697836" :: "nat" :: Type))))(({
    val rxyz = natInd.value.rec(Type)
    rxyz
  })("punit" :: Type)(lmbda("'h_159188406_1711678532" :: "nat" :: Type)(lmbda("'i_854809894_1639579534" :: Type)(("pprod" :: FuncTyp(Type, FuncTyp(Type, Type)))(("pprod" :: FuncTyp(Type, FuncTyp(Type, Type)))(piDefn("'aj_1427415108" :: "nat" :: Type)(("decidable" :: FuncTyp(Prop, Type))(("eq" :: piDefn("'c_888554361" :: Type)(FuncTyp("'c_888554361" :: Type, FuncTyp("'c_888554361" :: Type, Prop))))("nat" :: Type)("'h_159188406_1711678532" :: "nat" :: Type)("'aj_1427415108" :: "nat" :: Type))))("'i_854809894_1639579534" :: Type))("punit" :: Type))))("'v_256405719_429396927" :: "nat" :: Type)))("punit" :: Type)("'w_566843556_179354281" :: ("pprod" :: FuncTyp(Type, FuncTyp(Type, Type)))(piDefn("'aj_257559038" :: "nat" :: Type)(("decidable" :: FuncTyp(Prop, Type))(("eq" :: piDefn("'c_265527310" :: Type)(FuncTyp("'c_265527310" :: Type, FuncTyp("'c_265527310" :: Type, Prop))))("nat" :: Type)("'v_256405719_429396927" :: "nat" :: Type)("'aj_257559038" :: "nat" :: Type))))(({
    val rxyz = natInd.value.rec(Type)
    rxyz
  })("punit" :: Type)(lmbda("'h_159188406_696790367" :: "nat" :: Type)(lmbda("'i_854809894_317859634" :: Type)(("pprod" :: FuncTyp(Type, FuncTyp(Type, Type)))(("pprod" :: FuncTyp(Type, FuncTyp(Type, Type)))(piDefn("'aj_1612878706" :: "nat" :: Type)(("decidable" :: FuncTyp(Prop, Type))(("eq" :: piDefn("'c_479764664" :: Type)(FuncTyp("'c_479764664" :: Type, FuncTyp("'c_479764664" :: Type, Prop))))("nat" :: Type)("'h_159188406_696790367" :: "nat" :: Type)("'aj_1612878706" :: "nat" :: Type))))("'i_854809894_317859634" :: Type))("punit" :: Type))))("'v_256405719_429396927" :: "nat" :: Type)))("punit.star" :: "punit" :: Type)))))("'ag_1531296106_1367828936" :: "nat" :: Type)))
}

		</code>

	</pre>
</section>

		<section>
			<h3> NLP: extracting from human literature.</h3>
			<ul>
				<li class="fragment"> We aim to extract mathematical objects from the literature,
					with reasonably high accuracy. </li>
				<li class="fragment"> These can be used for learning, giving terms for generation and types as goals.</li>
				<li class="fragment"> This is a translation problem, except the target language has
					strong restrictions.</li>
				<li class="fragment"> To extract from natural language, we first
					<ul>
						<li>Use a natural language parser.</li>
						<li>Target an intermediate language (Naproche CNL).</li>
						<li>We will translate this into HoTT, combing with parsing latex formulas.</li>
					</ul>
				</li>
				</ul>
			</section>

	</section>

<section>
	<h3>Concluding Remarks</h3>
	<ul>
	  <li class="fragment">Systems such as AlphaZero show that computers can learn to make judgements, be creative etc.</li>
		<li class="fragment">Our first steps will expand the range of ways in which computers help in mathematics.</li>
		<li class="fragment">A better developed system will contribute to <em>semantic tooling</em> for mathematics.</li>
		<li class="fragment">Finally, if and when really powerful provers are developed, they can extend the reach of mathematics.</li>
	</ul>
</section>

<section>
	<h1>Thank You</h1>
</section>

<!-- Extra slides -->


<section>
	<ul>
		<li><strong>Lemma:</strong> If $x = s(wy)s^{-1} = t(zw^{-1})t^{-1}$, we have $l(x)\leq \frac{l(y)+ l(z)}{2}$.</li>
		<li class="fragment"><strong>Proof:</strong> $l(x^nx^n) = l(s(wy)^ns^{-1}t(zw^{-1})^nt^{-1})$ $\leq n(l(y) +l(z)) + 2(l(s) + l(t))$
			 <img src="internal-repetition.png" scale="20%" style="border:none; background-color: white;">
		</li>
		<li class="fragment">Use $l(x) = \frac{l(x^nx^n)}{2n}$ and take limits.</li>
	</ul>
</section>

<section>
	<ul>
		<li> <strong>Lemma:</strong> $f(m, k) \leq\frac{f(m-1, k) + f(m+1, k-1)}{2}$, where $f(m, k) = l(x^m[x, y]^k)$.</li>
		<li class="fragment">In other words, for $Y$ a Rademacher random variable, i.e., $Y$ is $1$ or $-1$ each with probability $1/2$,
			$f(m, k)\leq E(f( (m, k - 1/2) + Y(1, -1/2) ))$.</li>
		<li class="fragment">Hence for $Y_i$ i.i.d. Rademacher random variables, $f(0, n) \leq E(f((Y_1 + Y_2 + \dots + Y_{2n}) (1, -1/2) ))$,</li>
		<li class="fragment">By triangle inequality, $f(a, b) \leq A\Vert (a, b) \Vert$.</li>
		<li class="fragment">$Y_1 + Y_2 + \dots Y_{2n}$ has mean $(0, 0)$ and variance $2n$, so $E(\Vert Y_1 + Y_2 + \dots Y_{2n} \Vert) \leq B\sqrt{n}$.</li>
		<li class="fragment">We deduce that $l([x, y]^n) = f(0, n) \leq C\sqrt{n}$, hence $l([x, y]) = 0$.</li>
	</ul>
</section>

<section>
	<h3>Epilogue: Quasification</h3>
	<ul>
		<li class="fragment"> The function $l: G \to [0, \infty)$ is a <em>quasi-pseudo-length function</em>  if there exists $c \in \mathbb{R}$ such that
			 $l(gh) \leq l(g) + l(h) + c$, for all $g,h\in G$.
		<li class="fragment">We see that for a homogeneous quasi-pseudo-length function, $l([x, y]) \leq 4c$ for all $x, y\in G$.</li>
		<li class="fragment">Free groups have homogeneous quasi-pseudo-length functions that are not pullbacks of norms.</li>
		<li class="fragment"> But, for a group with vanishing <em>stable commutator length</em>, e.g. if $G$ is solvable or $G=Sl(n , \mathbb{Z})$, $n\geq 3$, <span class="fragment">any homogeneous
			quasi-pseudo-length function is equivalent to the pullback of a norm.</span></li>
	</ul>
</section>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom


				math: {
					// mathjax: '../MathJax/MathJax.js',
					mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js',
					config: 'TeX-AMS_HTML-full' // See http://docs.mathjax.org/en/latest/config-files.html
				},

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/math/math.js', async: true}
				]
			});

//			Reveal.addEventListener( 'slidechanged', function( event ) {
//				MathJax.Hub.Rerender();
//			} );

		</script>

	</body>
</html>
