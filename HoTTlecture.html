<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Homotopy Type theory</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/moon.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

<div class="reveal">

<!-- Any section element inside of this container is displayed as a slide -->
<div class="slides">
<section>
	<h1> Homotopy Type Theory </h1>
	 <h3>Siddhartha Gadgil</h3>
	 <p>Department of Mathematics</p>
	 <p>Indian Institute of Science</p>
	 <p>Bangalore</p>
</section>

<section>
	<section>
		<h3>Foundations of Mathematics</h3>
		 <p>Languages and Axioms</p>
		 <p>Sets and Predicate Calculus</p>
		 <p>Why we need new foundations</p>
	</section>

</section>

<section>
	<section>
		<h3>Type theories</h3>
		 <p>Syntax with types</p>
		 <p>Types for sets</p>
		 <p> Propositions as Types</p>
	</section>

</section>

<section>
	<section>
		<h3> (Homotopy) Type theory</h3>
		 <p>Terms, Types, Rules</p>
		 <p>Inductive types</p>
		 <p>Propositions as types</p>
		 <p>Proofs by inductions</p>
	</section>
	<section>
	  <h3> Terms, Types, Universes </h3>
	  <ul>
	  <li class="fragment"> <em>Terms </em>, i.e., mathematical objects, include not just numbes, functions, spaces but also theorems, proofs and definitions.</li>
	  <div class="fragment"><li> Every term has a <em> type </em>, generally unique.</li>
	    <li> We write $a : A$ to denote the term $a$ having type $A$.
	      </div>
	  <div class="fragment"> 
	    <li> Types are also terms, whose types are <em> universes</em>.
	      <li> A universe is a type whose members are types.</li>
	      </div>
	  </ul>
	  </section>
	<section>
	  <h3> Rules: construction, equality, type, substitution</h3>
	  <ul>
	    <li class="fragment"> We have rules to introduce terms(including types), individually or in groups, into the context</li>	    
	    <li class="fragment"> As always, such rules depend on pre-existing terms only through their types.</li>
	    <li class="fragment"> Rules also let us make two kinds of judgements:
	      <ul>
		<li> that a term $a$  is of type $A$. </li>
		<li> that two terms are equal <em> by definition </em>.
	      </ul></li>
	    <li class="fragment">  Note that terms can be equal without being so by definition. This corresponds to a relation <em> propositional equality</em> that is introduced (so is not part of the foundations).</li>
	    <li class="fragment"> We have rules giving the result of substituting a term $(a : A)$ by a term $(a' : A)$ in a term $x$.</li>
	    </ul>
	</section>
	
	<section>
	  <h3> A finite type : Booleans</h3>
	  <ul> 
	    <li class="fragment"> We can introduce a finite type together with its elements.</li>
	    <li class="fragment"> For instance, we can introduce the <em>Boolean</em> type with two members, <em> true</em> and <em> false</em>.</li>
	    <div class="fragment">
	      <li> In terms of code in the language/proof-assistant <em> Agda</em>,</li>
<pre><code class="haskell">
data Bool : Type where 
  true : Bool
  false : Bool

</code></pre>
</div>
	    <li class="fragment"> Note that we do not have rules saying (directly) that each element of $Bool$ is one of $true$ and $false$, or that $true\neq false$.</li>
	</section>

	<section> 
	  <h3> Function types, functions and applications </h3>
	  <ul>
	    <li class="fragment"> Given types $A$ and $B$, we can introduce the function type $A \to B$, whose members are functions.</li>
	    <li class="fragment"> Given $f: A \to B$ and $a : A$, we get a term $f(a) : B$.</li>
	    <div class="fragment">
	      <li> We can construct a function $f: A \to B$ by giving an expression of type $B$ in terms of a variable $a : A$ and other terms in the context.</li>
<pre><code class="haskell">
idBool : Bool → Bool -- lambda
idBool x = x

alwaysTrue : Bool → Bool
alwaysTrue x = true
</code></pre>
</div>
	    <li class="fragment"> For specific domains $A$, we have additional rules for constructing functions.</li>
	    </ul>
	</section>

	<section>
	  <h3> Definition by cases </h3>
	  <ul>
	  <li class="fragment"> If the type $A$ is a finite type, we can define a function by enumerating over all members.</li>
<div class="fragment">
<pre><code class="haskell">
not : Bool → Bool -- case defn
not true = false
not false = true

notnot : Bool → Bool -- lambda
notnot x = not(not(x))
</code></pre>
</div>
	  <li class="fragment"> Implicit in being able to make such definitions are statements saying that $true$ and $false$ are distinct and the only members of $Bool$. 
	  <li class="fragment"> This is a special instance of recursive definitions.</li>
	  <li class="fragment"> Formally, in homotopy type theory we have rules for introducing a <em> recursion </em> function, which is applied to the definition data to give recursive defintions.
	    </li>
	  </ul>
	</section>
	<section> 
	  <h3> Currying functions of several variables</h3>
	  <ul>
	    <li class="fragment"> We do not need additional types for functions of more than one variable.</li>
	    <li class="fragment"> Instead we <em> Curry </em> such a function $(A, B) \to C$, giving an <em> iterated function </em> $A \to B \to C = A \to (B \to C)$.</li>
	    <li class="fragment"> Namely, we associate to $g(x, y)$ the function $x \mapsto (y \mapsto g(x, y))$</li>
<div class="fragment">
<pre><code class="haskell">
_&_ : Bool → Bool → Bool --curried function
true & x = x
false & _ = false

</code></pre>
</ul>
	</section>

	<section>
	  <h3> Natural numbers : an inductive type</h3>
	  <ul>
	    <li class="fragment"> Though natural numbers are not finite, they are freely generated by a finite class of constructors.</li>
<div class="fragment">
<pre><code class="haskell">
data ℕ : Type where -- infinite type
  zero : ℕ
  succ : ℕ → ℕ

</code></pre>
</div>
	    <li class="fragment">Such a type is called the inductive type freely generated by the given constructors.</li>
	    <li class="fragment"> Rules giving the allowed types of the constructors are a little subtle.</li>
	    </ul>
	  </section>

	<section>
	  <h3> Recursive definitions </h3>
	  <ul>
	    <li class="fragment"> We can define functions recursively on inductive types, by specifying in all cases.</li>
	    <li class="fragment"> Formally, we can introduce recursion functions and apply them to the definition data </li>
	    </ul>
<div class="fragment">
<pre><code class="haskell">
even : ℕ → Bool -- recursive definition
even zero = true
even (succ x) = not (even x)

_+_ : ℕ → ℕ → ℕ 
zero + y = y
succ x + y = x + succ y

</code></pre>
</div>
	</section>

	<section>
	  <h3> Lists : Another Inductive type </h3>
<div class="fragment">
<pre><code class="haskell">
data ℕList : Type where --list type 
  [] : ℕList -- empty list 
  _::_ : ℕ → ℕList → ℕList -- add number to head of list

mylist : ℕList 
mylist = 3 :: (4 :: (2 :: [])) -- the list [3, 4, 2]

</code></pre>
</div>
	</section>

	<section>
	  <h3> Dependent functions and type families </h3>
	  <ul>
	    <li class="fragment"> We generalize functions $f : A \to B$ to <em> dependent functions</em>, so that $f(a)$ has a type $B(a)$, depending in general on $a : A$.</li>
	    <li class="fragment"> More precisely,
	      <ul>
		<li class="fragment"> A <em> type family</em> $B: A \to \mathcal{U}$ is a function with codomain a universe, so all its values are types. </li>
		<li class="fragment"> Given a type family $B: A \to \mathcal{U}$, we can construct a corresponding type $\Pi_{a : A} B(a)$ of dependent functions.</li>
		<li class="fragment"> When we apply $f : \Pi_{a : A} B(a)$ to $a : A$, we obtain $f(a) : B(a)$</li>
		</ul>
	      </li>
	  <li class="fragment"> Dependent functions are just sections of bundles </li>
	  <li class="fragment"> Constructions of dependent functions are analogous to those of functions.</li>
	  </ul>
	  </section>

	<section> 
	  <h3>Vectors : an inductive type family </h3>
	  <ul>
	    <li class="fragment"> We have a type family associating to each $n : \mathbb{N}$ the type of vectors of length $n$ with entries in $\mathbb{N}$.</li>
	    <li class="fragment"> This is an inductive type family with two constructors.</li>
<div class="fragment">
<pre><code class="haskell">
data Vector : ℕ → Type where -- type family
  [] : Vector 0
  _::_ : {n : ℕ} → ℕ → Vector n → Vector (succ n) 
</code></pre>
</div>
	    <li class="fragment"> We can define dependent functions to this type family <em>inductively</em>.</li>
<div class="fragment">
<pre><code class="haskell">
countdown : (n : ℕ) → Vector n -- dependent function
countdown 0 = []
countdown (succ n) = (succ n) :: (countdown n)
</code></pre>
</div>
	    <li class="fragment"> Formally, we can construct an <em>induction function</em> and apply it to the data.</li>
	  </ul>
	  </section>

	<section>
	  <h3> Functions on type families </h3>
	  <ul>
	    <li class="fragment"> We can define (dependent) functions on inductive type families recursively (inductively).</li>
	    <li class="fragment"> However, we must define these simultaneously on all types in the inductive type family</li>
<div class="fragment">
<pre><code class="haskell">
sum : {n : ℕ} → Vector n → ℕ
sum [] = 0
sum (x :: l) = x + sum l
</code></pre>
</div>
	    <li class="fragment"> Using our foundations, we can also make some practical calculations.</li>
<div class="fragment">
<pre><code class="haskell">
sumToN : ℕ → ℕ -- calculation
sumToN n = sum(countdown n)
</code></pre>
</div>

	  </ul>
	  </section>

	<section>
	  <h3> Propositions from inductive types </h3>
	  <ul>
	    <li class="fragment"> We view propositions as types, with members of the type witnesses (or proofs).</li>
	    <li class="fragment"> Basic propositions can be constructed as inductive types.</li>
<div class="fragment">
<pre><code class="haskell">
data isEven : ℕ → Type where
  0even : isEven 0
  +2even : (n : ℕ) → isEven n → isEven (succ(succ(n)))
</code></pre>
</div>

	    <li class="fragment"> We can prove results using our methods of construction.</li>
<div class="fragment">
<pre><code class="haskell">
4even : isEven 4
4even = +2even _ (+2even _ 0even)
</code></pre>
</div>
	    </ul>
	  </section>

	<section>
	  <ul>
	    <li class="fragment"> For propositions $A$ and $B$ viewed as types, $A \implies B$ corresponds to $A \to B$.</li>
	    <li class="fragment"> A contradiction corresponds to the type $\mathbb{0}$ (also called $False$) which has no elements.</li>
	    <li class="fragment"> We prove contradictions by inductive definitions which we can see have no cases.</li>
<div class="fragment">
<pre><code class="haskell">
data False : Type where

1odd : isEven 1 → False
1odd ()

3odd : isEven 3 → False
3odd (+2even .1 ())

</code></pre>
</div>
	  </ul>
	  </section>

	<section>
	  <h3> Functions with conditions </h3>
	  <ul>
	    <li class="fragment"> In mathematics (and software), we often define functions subject to the argument satisfying some condition.</li>
	    <li class="fragment"> This can be done very elegantly with propositions as types.</li>
<div class="fragment">
<pre><code class="haskell">
half : (n : ℕ) → isEven n → ℕ
half .0 0even = 0
half .(succ (succ n)) (+2even n pf) = succ(half n pf)

</code></pre>
</div>
	  </ul>
	</section>

	<section>
	  <h3> A proof by induction </h3>
<div class="fragment">
<pre><code class="haskell">
double : (n : ℕ) → ℕ
double 0 = 0
double (succ n) = succ(succ(double(n)))

step : (n : ℕ) → (isEven (double n)) → isEven (double(succ(n)))
step n pf = +2even _ pf

thm : (n  : ℕ) → isEven (double n)
thm zero = 0even
thm (succ n) = step _ (thm n)

halfOfDouble : ℕ → ℕ
halfOfDouble n = half (double n) (thm n)

</code></pre>
</div>
	</section>

</section>


<section>
	<section>
		<h3>Homotopy type theory:</h3>
		<p> Equality and Paths </p>
		<p> Type families as fibrations </p>
		<p> $\infty$-groupoids from induction for equality</p>
	</section>

	<section>
	  <h3> Associativity up to homotopy : the Pentagon </h3>
	  <img src="pentagon.svg" />
	</section>
</section>



<section>

	<section>
	<h1> Code </h1>
</section>

<section>
<pre><code class="haskell">
data True : Set where
  qed : True

data False : Set where
</code></pre>
</section>

</section>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom


				math: {
					mathjax: '../MathJax/MathJax.js',
					// mathjax: 'http://cdn.mathjax.org/mathjax/latest/MathJax.js',
					config: 'TeX-AMS_HTML-full' // See http://docs.mathjax.org/en/latest/config-files.html
				},

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../highlight/highlight.pack.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/math/math.js', async: true}
				]
			});

//			Reveal.addEventListener( 'slidechanged', function( event ) {
//				MathJax.Hub.Rerender();
//			} );

		</script>

	</body>
</html>
